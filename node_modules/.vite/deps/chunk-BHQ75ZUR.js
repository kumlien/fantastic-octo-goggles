import {
  dedupingMixin
} from "./chunk-GBJGMIIH.js";

// node_modules/@vaadin/component-base/src/controller-mixin.js
var ControllerMixin = dedupingMixin((superClass) => {
  if (typeof superClass.prototype.addController === "function") {
    return superClass;
  }
  return class ControllerMixinClass extends superClass {
    constructor() {
      super();
      this.__controllers = /* @__PURE__ */ new Set();
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      this.__controllers.forEach((c) => {
        if (c.hostConnected) {
          c.hostConnected();
        }
      });
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.__controllers.forEach((c) => {
        if (c.hostDisconnected) {
          c.hostDisconnected();
        }
      });
    }
    /**
     * Registers a controller to participate in the element update cycle.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    addController(controller) {
      this.__controllers.add(controller);
      if (this.$ !== void 0 && this.isConnected && controller.hostConnected) {
        controller.hostConnected();
      }
    }
    /**
     * Removes a controller from the element.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    removeController(controller) {
      this.__controllers.delete(controller);
    }
  };
});

// node_modules/@vaadin/a11y-base/src/focus-utils.js
var keyboardActive = false;
window.addEventListener(
  "keydown",
  () => {
    keyboardActive = true;
  },
  { capture: true }
);
window.addEventListener(
  "mousedown",
  () => {
    keyboardActive = false;
  },
  { capture: true }
);
function isKeyboardActive() {
  return keyboardActive;
}
function isElementHiddenDirectly(element) {
  const style = element.style;
  if (style.visibility === "hidden" || style.display === "none") {
    return true;
  }
  const computedStyle = window.getComputedStyle(element);
  if (computedStyle.visibility === "hidden" || computedStyle.display === "none") {
    return true;
  }
  return false;
}
function hasLowerTabOrder(a, b) {
  const ati = Math.max(a.tabIndex, 0);
  const bti = Math.max(b.tabIndex, 0);
  return ati === 0 || bti === 0 ? bti > ati : ati > bti;
}
function mergeSortByTabIndex(left, right) {
  const result = [];
  while (left.length > 0 && right.length > 0) {
    if (hasLowerTabOrder(left[0], right[0])) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  return result.concat(left, right);
}
function sortElementsByTabIndex(elements) {
  const len = elements.length;
  if (len < 2) {
    return elements;
  }
  const pivot = Math.ceil(len / 2);
  const left = sortElementsByTabIndex(elements.slice(0, pivot));
  const right = sortElementsByTabIndex(elements.slice(pivot));
  return mergeSortByTabIndex(left, right);
}
function isElementHidden(element) {
  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {
    return true;
  }
  return isElementHiddenDirectly(element);
}
function isElementFocusable(element) {
  if (element.matches('[tabindex="-1"]')) {
    return false;
  }
  if (element.matches("input, select, textarea, button, object")) {
    return element.matches(":not([disabled])");
  }
  return element.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function isElementFocused(element) {
  return element.getRootNode().activeElement === element;
}
function normalizeTabIndex(element) {
  if (!isElementFocusable(element)) {
    return -1;
  }
  const tabIndex = element.getAttribute("tabindex") || 0;
  return Number(tabIndex);
}
function collectFocusableNodes(node, result) {
  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {
    return false;
  }
  const element = (
    /** @type {HTMLElement} */
    node
  );
  const tabIndex = normalizeTabIndex(element);
  let needsSort = tabIndex > 0;
  if (tabIndex >= 0) {
    result.push(element);
  }
  let children = [];
  if (element.localName === "slot") {
    children = element.assignedNodes({ flatten: true });
  } else {
    children = (element.shadowRoot || element).children;
  }
  [...children].forEach((child) => {
    needsSort = collectFocusableNodes(child, result) || needsSort;
  });
  return needsSort;
}
function getFocusableElements(element) {
  const focusableElements = [];
  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);
  if (needsSortByTabIndex) {
    return sortElementsByTabIndex(focusableElements);
  }
  return focusableElements;
}

export {
  isKeyboardActive,
  isElementHidden,
  isElementFocused,
  getFocusableElements,
  ControllerMixin
};
/*! Bundled license information:

@vaadin/component-base/src/controller-mixin.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/a11y-base/src/focus-utils.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-BHQ75ZUR.js.map
