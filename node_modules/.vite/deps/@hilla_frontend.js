import {
  property
} from "./chunk-YFFYBNPL.js";
import {
  classMap
} from "./chunk-6MA6C4FO.js";
import {
  LitElement
} from "./chunk-7YBXQWTC.js";
import {
  html
} from "./chunk-ZM44JEQ2.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-FNWUTXRW.js";

// node_modules/atmosphere.js/lib/atmosphere.js
var require_atmosphere = __commonJS({
  "node_modules/atmosphere.js/lib/atmosphere.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports !== "undefined") {
        module.exports = factory();
      } else {
        root.atmosphere = factory();
      }
    })(exports, function() {
      "use strict";
      var atmosphere = {}, guid, offline = false, requests = [], callbacks = [], uuid = 0, hasOwn = Object.prototype.hasOwnProperty;
      atmosphere = {
        version: "3.1.3-javascript",
        onError: function(response) {
        },
        onClose: function(response) {
        },
        onOpen: function(response) {
        },
        onReopen: function(response) {
        },
        onMessage: function(response) {
        },
        onReconnect: function(request, response) {
        },
        onMessagePublished: function(response) {
        },
        onTransportFailure: function(errorMessage, _request) {
        },
        onLocalMessage: function(response) {
        },
        onFailureToReconnect: function(request, response) {
        },
        onClientTimeout: function(request) {
        },
        onOpenAfterResume: function(request) {
        },
        /**
         * Creates an object based on an atmosphere subscription that exposes functions defined by the Websocket interface.
         *
         * @class WebsocketApiAdapter
         * @param {Object} request the request object to build the underlying subscription
         * @constructor
         */
        WebsocketApiAdapter: function(request) {
          var _socket, _adapter;
          request.onMessage = function(e2) {
            _adapter.onmessage({ data: e2.responseBody });
          };
          request.onMessagePublished = function(e2) {
            _adapter.onmessage({ data: e2.responseBody });
          };
          request.onOpen = function(e2) {
            _adapter.onopen(e2);
          };
          _adapter = {
            close: function() {
              _socket.close();
            },
            send: function(data) {
              _socket.push(data);
            },
            onmessage: function(e2) {
            },
            onopen: function(e2) {
            },
            onclose: function(e2) {
            },
            onerror: function(e2) {
            }
          };
          _socket = new atmosphere.subscribe(request);
          return _adapter;
        },
        AtmosphereRequest: function(options) {
          var _request = {
            timeout: 3e5,
            method: "GET",
            headers: {},
            contentType: "",
            callback: null,
            url: "",
            data: "",
            suspend: true,
            maxRequest: -1,
            reconnect: true,
            maxStreamingLength: 1e7,
            lastIndex: 0,
            logLevel: "info",
            requestCount: 0,
            fallbackMethod: "GET",
            fallbackTransport: "streaming",
            transport: "long-polling",
            webSocketImpl: null,
            webSocketBinaryType: null,
            dispatchUrl: null,
            webSocketPathDelimiter: "@@",
            enableXDR: false,
            rewriteURL: false,
            attachHeadersAsQueryString: true,
            executeCallbackBeforeReconnect: false,
            readyState: 0,
            withCredentials: false,
            trackMessageLength: false,
            messageDelimiter: "|",
            connectTimeout: -1,
            reconnectInterval: 0,
            dropHeaders: true,
            uuid: 0,
            shared: false,
            readResponsesHeaders: false,
            maxReconnectOnClose: 5,
            enableProtocol: true,
            disableDisconnect: false,
            pollingInterval: 0,
            heartbeat: {
              client: null,
              server: null
            },
            ackInterval: 0,
            reconnectOnServerError: true,
            handleOnlineOffline: true,
            maxWebsocketErrorRetries: 1,
            curWebsocketErrorRetries: 0,
            unloadBackwardCompat: !navigator.sendBeacon,
            onError: function(response) {
            },
            onClose: function(response) {
            },
            onOpen: function(response) {
            },
            onMessage: function(response) {
            },
            onReopen: function(request, response) {
            },
            onReconnect: function(request, response) {
            },
            onMessagePublished: function(response) {
            },
            onTransportFailure: function(reason, request) {
            },
            onLocalMessage: function(request) {
            },
            onFailureToReconnect: function(request, response) {
            },
            onClientTimeout: function(request) {
            },
            onOpenAfterResume: function(request) {
            }
          };
          var _response = {
            status: 200,
            reasonPhrase: "OK",
            responseBody: "",
            messages: [],
            headers: [],
            state: "messageReceived",
            transport: "polling",
            error: null,
            request: null,
            partialMessage: "",
            errorHandled: false,
            closedByClientTimeout: false,
            ffTryingReconnect: false
          };
          var _websocket = null;
          var _sse = null;
          var _activeRequest = null;
          var _ieStream = null;
          var _jqxhr = null;
          var _subscribed = true;
          var _requestCount = 0;
          var _heartbeatInterval = 0;
          var _heartbeatPadding = "X";
          var _abortingConnection = false;
          var _localSocketF = null;
          var _storageService;
          var _localStorageService = null;
          var guid2 = atmosphere.util.now();
          var _traceTimer;
          var _sharingKey;
          var _beforeUnloadState = false;
          _subscribe(options);
          function _init() {
            _subscribed = true;
            _abortingConnection = false;
            _requestCount = 0;
            _websocket = null;
            _sse = null;
            _activeRequest = null;
            _ieStream = null;
          }
          function _reinit() {
            _clearState();
            _init();
          }
          function _canLog(level) {
            if (level == "debug") {
              return _request.logLevel === "debug";
            } else if (level == "info") {
              return _request.logLevel === "info" || _request.logLevel === "debug";
            } else if (level == "warn") {
              return _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
            } else if (level == "error") {
              return _request.logLevel === "error" || _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
            } else {
              return false;
            }
          }
          function _debug(msg) {
            if (_canLog("debug")) {
              atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: " + msg);
            }
          }
          function _verifyStreamingLength(ajaxRequest, rq) {
            if (_response.partialMessage === "" && rq.transport === "streaming" && ajaxRequest.responseText.length > rq.maxStreamingLength) {
              return true;
            }
            return false;
          }
          function _disconnect() {
            if (_request.enableProtocol && !_request.disableDisconnect && !_request.firstMessage) {
              var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;
              atmosphere.util.each(_request.headers, function(name, value) {
                var h = atmosphere.util.isFunction(value) ? value.call(this, _request, _request, _response) : value;
                if (h != null) {
                  query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                }
              });
              var url = _request.url.replace(/([?&])_=[^&]*/, query);
              url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");
              var rq = {
                connected: false
              };
              var closeR = new atmosphere.AtmosphereRequest(rq);
              closeR.connectTimeout = _request.connectTimeout;
              closeR.attachHeadersAsQueryString = false;
              closeR.dropHeaders = true;
              closeR.url = url;
              closeR.contentType = "text/plain";
              closeR.transport = "polling";
              closeR.method = "GET";
              closeR.data = "";
              closeR.heartbeat = null;
              if (_request.enableXDR) {
                closeR.enableXDR = _request.enableXDR;
              }
              _pushOnClose("", closeR);
            }
          }
          function _close() {
            _debug("Closing (AtmosphereRequest._close() called)");
            _abortingConnection = true;
            if (_request.reconnectId) {
              clearTimeout(_request.reconnectId);
              delete _request.reconnectId;
            }
            if (_request.heartbeatTimer) {
              clearTimeout(_request.heartbeatTimer);
            }
            _request.reconnect = false;
            _response.request = _request;
            _response.state = "unsubscribe";
            _response.responseBody = "";
            _response.status = 408;
            _response.partialMessage = "";
            _request.curWebsocketErrorRetries = 0;
            _invokeCallback();
            _disconnect();
            _clearState();
          }
          function _clearState() {
            _response.partialMessage = "";
            if (_request.id) {
              clearTimeout(_request.id);
            }
            if (_request.heartbeatTimer) {
              clearTimeout(_request.heartbeatTimer);
            }
            if (_request.reconnectId) {
              clearTimeout(_request.reconnectId);
              delete _request.reconnectId;
            }
            if (_ieStream != null) {
              _ieStream.close();
              _ieStream = null;
            }
            if (_jqxhr != null) {
              _jqxhr.abort();
              _jqxhr = null;
            }
            if (_activeRequest != null) {
              _activeRequest.abort();
              _activeRequest = null;
            }
            if (_websocket != null) {
              if (_websocket.canSendMessage) {
                _debug("invoking .close() on WebSocket object");
                _websocket.close();
              }
              _websocket = null;
            }
            if (_sse != null) {
              _sse.close();
              _sse = null;
            }
            _clearStorage();
          }
          function _clearStorage() {
            if (_storageService != null) {
              clearInterval(_traceTimer);
              document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
              _storageService.signal("close", {
                reason: "",
                heir: !_abortingConnection ? guid2 : (_storageService.get("children") || [])[0]
              });
              _storageService.close();
            }
            if (_localStorageService != null) {
              _localStorageService.close();
            }
          }
          function _subscribe(options2) {
            _reinit();
            _request = atmosphere.util.extend(_request, options2);
            _request.mrequest = _request.reconnect;
            if (!_request.reconnect) {
              _request.reconnect = true;
            }
          }
          function _supportWebsocket() {
            return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
          }
          function _supportSSE() {
            var url = atmosphere.util.getAbsoluteURL(_request.url.toLowerCase());
            var parts = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(url);
            var crossOrigin = !!(parts && // protocol
            (parts[1] != window.location.protocol || // hostname
            parts[2] != window.location.hostname || // port
            (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (window.location.port || (window.location.protocol === "http:" ? 80 : 443))));
            return window.EventSource && (!crossOrigin || !atmosphere.util.browser.safari || atmosphere.util.browser.vmajor >= 7);
          }
          function _execute() {
            if (_request.shared) {
              _localStorageService = _local(_request);
              if (_localStorageService != null) {
                if (_canLog("debug")) {
                  atmosphere.util.debug("Storage service available. All communication will be local");
                }
                if (_localStorageService.open(_request)) {
                  return;
                }
              }
              if (_canLog("debug")) {
                atmosphere.util.debug("No Storage service available.");
              }
              _localStorageService = null;
            }
            _request.firstMessage = uuid == 0 ? true : false;
            _request.isOpen = false;
            _request.ctime = atmosphere.util.now();
            if (_request.uuid === 0) {
              _request.uuid = uuid;
            }
            _response.closedByClientTimeout = false;
            if (_request.transport !== "websocket" && _request.transport !== "sse") {
              _executeRequest(_request);
            } else if (_request.transport === "websocket") {
              if (!_supportWebsocket()) {
                _reconnectWithFallbackTransport("Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
              } else {
                _executeWebSocket(false);
              }
            } else if (_request.transport === "sse") {
              if (!_supportSSE()) {
                _reconnectWithFallbackTransport("Server Side Events(SSE) is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
              } else {
                _executeSSE(false);
              }
            }
          }
          function _local(request) {
            var trace, connector, orphan, name = "atmosphere-" + request.url, connectors = {
              storage: function() {
                function onstorage(event) {
                  if (event.key === name && event.newValue) {
                    listener(event.newValue);
                  }
                }
                if (!atmosphere.util.storage) {
                  return;
                }
                var storage = window.localStorage, get = function(key) {
                  var item = storage.getItem(name + "-" + key);
                  return item === null ? [] : JSON.parse(item);
                }, set = function(key, value) {
                  storage.setItem(name + "-" + key, JSON.stringify(value));
                };
                return {
                  init: function() {
                    set("children", get("children").concat([guid2]));
                    atmosphere.util.on(window, "storage", onstorage);
                    return get("opened");
                  },
                  signal: function(type, data) {
                    storage.setItem(name, JSON.stringify({
                      target: "p",
                      type,
                      data
                    }));
                  },
                  close: function() {
                    var children = get("children");
                    atmosphere.util.off(window, "storage", onstorage);
                    if (children) {
                      if (removeFromArray(children, request.id)) {
                        set("children", children);
                      }
                    }
                  }
                };
              },
              windowref: function() {
                var win = window.open("", name.replace(/\W/g, ""));
                if (!win || win.closed || !win.callbacks) {
                  return;
                }
                return {
                  init: function() {
                    win.callbacks.push(listener);
                    win.children.push(guid2);
                    return win.opened;
                  },
                  signal: function(type, data) {
                    if (!win.closed && win.fire) {
                      win.fire(JSON.stringify({
                        target: "p",
                        type,
                        data
                      }));
                    }
                  },
                  close: function() {
                    if (!orphan) {
                      removeFromArray(win.callbacks, listener);
                      removeFromArray(win.children, guid2);
                    }
                  }
                };
              }
            };
            function removeFromArray(array, val) {
              var i4, length = array.length;
              for (i4 = 0; i4 < length; i4++) {
                if (array[i4] === val) {
                  array.splice(i4, 1);
                }
              }
              return length !== array.length;
            }
            function listener(string) {
              var command = JSON.parse(string), data = command.data;
              if (command.target === "c") {
                switch (command.type) {
                  case "open":
                    _open("opening", "local", _request);
                    break;
                  case "close":
                    if (!orphan) {
                      orphan = true;
                      if (data.reason === "aborted") {
                        _close();
                      } else {
                        if (data.heir === guid2) {
                          _execute();
                        } else {
                          setTimeout(function() {
                            _execute();
                          }, 100);
                        }
                      }
                    }
                    break;
                  case "message":
                    _prepareCallback(data, "messageReceived", 200, request.transport);
                    break;
                  case "localMessage":
                    _localMessage(data);
                    break;
                }
              }
            }
            function findTrace() {
              var matcher = new RegExp("(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)").exec(document.cookie);
              if (matcher) {
                return JSON.parse(decodeURIComponent(matcher[2]));
              }
            }
            trace = findTrace();
            if (!trace || atmosphere.util.now() - trace.ts > 1e3) {
              return;
            }
            connector = connectors.storage() || connectors.windowref();
            if (!connector) {
              return;
            }
            return {
              open: function() {
                var parentOpened;
                _traceTimer = setInterval(function() {
                  var oldTrace = trace;
                  trace = findTrace();
                  if (!trace || oldTrace.ts === trace.ts) {
                    listener(JSON.stringify({
                      target: "c",
                      type: "close",
                      data: {
                        reason: "error",
                        heir: oldTrace.heir
                      }
                    }));
                  }
                }, 1e3);
                parentOpened = connector.init();
                if (parentOpened) {
                  setTimeout(function() {
                    _open("opening", "local", request);
                  }, 50);
                }
                return parentOpened;
              },
              send: function(event) {
                connector.signal("send", event);
              },
              localSend: function(event) {
                connector.signal("localSend", JSON.stringify({
                  id: guid2,
                  event
                }));
              },
              close: function() {
                if (!_abortingConnection) {
                  clearInterval(_traceTimer);
                  connector.signal("close");
                  connector.close();
                }
              }
            };
          }
          function share() {
            var storageService, name = "atmosphere-" + _request.url, servers = {
              // Powered by the storage event and the localStorage
              // http://www.w3.org/TR/webstorage/#event-storage
              storage: function() {
                function onstorage(event) {
                  if (event.key === name && event.newValue) {
                    listener(event.newValue);
                  }
                }
                if (!atmosphere.util.storage) {
                  return;
                }
                var storage = window.localStorage;
                return {
                  init: function() {
                    atmosphere.util.on(window, "storage", onstorage);
                  },
                  signal: function(type, data) {
                    storage.setItem(name, JSON.stringify({
                      target: "c",
                      type,
                      data
                    }));
                  },
                  get: function(key) {
                    return JSON.parse(storage.getItem(name + "-" + key));
                  },
                  set: function(key, value) {
                    storage.setItem(name + "-" + key, JSON.stringify(value));
                  },
                  close: function() {
                    atmosphere.util.off(window, "storage", onstorage);
                    storage.removeItem(name);
                    storage.removeItem(name + "-opened");
                    storage.removeItem(name + "-children");
                  }
                };
              },
              // Powered by the window.open method
              // https://developer.mozilla.org/en/DOM/window.open
              windowref: function() {
                var neim = name.replace(/\W/g, ""), container = document.getElementById(neim), win;
                if (!container) {
                  container = document.createElement("div");
                  container.id = neim;
                  container.style.display = "none";
                  container.innerHTML = '<iframe name="' + neim + '"></iframe>';
                  document.body.appendChild(container);
                }
                win = container.firstChild.contentWindow;
                return {
                  init: function() {
                    win.callbacks = [listener];
                    win.fire = function(string) {
                      var i4;
                      for (i4 = 0; i4 < win.callbacks.length; i4++) {
                        win.callbacks[i4](string);
                      }
                    };
                  },
                  signal: function(type, data) {
                    if (!win.closed && win.fire) {
                      win.fire(JSON.stringify({
                        target: "c",
                        type,
                        data
                      }));
                    }
                  },
                  get: function(key) {
                    return !win.closed ? win[key] : null;
                  },
                  set: function(key, value) {
                    if (!win.closed) {
                      win[key] = value;
                    }
                  },
                  close: function() {
                  }
                };
              }
            };
            function listener(string) {
              var command = JSON.parse(string), data = command.data;
              if (command.target === "p") {
                switch (command.type) {
                  case "send":
                    _push(data);
                    break;
                  case "localSend":
                    _localMessage(data);
                    break;
                  case "close":
                    _close();
                    break;
                }
              }
            }
            _localSocketF = function propagateMessageEvent(context) {
              storageService.signal("message", context);
            };
            function leaveTrace() {
              document.cookie = _sharingKey + "=" + // Opera's JSON implementation ignores a number whose a last digit of 0 strangely
              // but has no problem with a number whose a last digit of 9 + 1
              encodeURIComponent(JSON.stringify({
                ts: atmosphere.util.now() + 1,
                heir: (storageService.get("children") || [])[0]
              })) + "; path=/";
            }
            storageService = servers.storage() || servers.windowref();
            storageService.init();
            if (_canLog("debug")) {
              atmosphere.util.debug("Installed StorageService " + storageService);
            }
            storageService.set("children", []);
            if (storageService.get("opened") != null && !storageService.get("opened")) {
              storageService.set("opened", false);
            }
            _sharingKey = encodeURIComponent(name);
            leaveTrace();
            _traceTimer = setInterval(leaveTrace, 1e3);
            _storageService = storageService;
          }
          function _open(state, transport, request) {
            if (_request.shared && transport !== "local") {
              share();
            }
            if (_storageService != null) {
              _storageService.set("opened", true);
            }
            request.close = function() {
              _close();
            };
            if (_requestCount > 0 && state === "re-connecting") {
              request.isReopen = true;
              _tryingToReconnect(_response);
            } else if (!_response.error) {
              _response.request = request;
              var prevState = _response.state;
              _response.state = state;
              var prevTransport = _response.transport;
              _response.transport = transport;
              var _body = _response.responseBody;
              _invokeCallback();
              _response.responseBody = _body;
              _response.state = prevState;
              _response.transport = prevTransport;
            }
          }
          function _jsonp(request) {
            request.transport = "jsonp";
            var rq = _request, script;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            _jqxhr = {
              open: function() {
                var callback = "atmosphere" + ++guid2;
                function _reconnectOnFailure() {
                  rq.lastIndex = 0;
                  if (rq.openId) {
                    clearTimeout(rq.openId);
                  }
                  if (rq.heartbeatTimer) {
                    clearTimeout(rq.heartbeatTimer);
                  }
                  if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                    _open("re-connecting", rq.transport, rq);
                    _reconnect(_jqxhr, rq, request.reconnectInterval);
                    rq.openId = setTimeout(function() {
                      _triggerOpen(rq);
                    }, rq.reconnectInterval + 1e3);
                  } else {
                    _onError(0, "maxReconnectOnClose reached");
                  }
                }
                function poll() {
                  var url = rq.url;
                  if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                  }
                  var data = rq.data;
                  if (rq.attachHeadersAsQueryString) {
                    url = _attachHeaders(rq);
                    if (data !== "") {
                      url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                    }
                    data = "";
                  }
                  var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
                  script = document.createElement("script");
                  script.src = url + "&jsonpTransport=" + callback;
                  script.clean = function() {
                    script.clean = script.onerror = script.onload = script.onreadystatechange = null;
                    if (script.parentNode) {
                      script.parentNode.removeChild(script);
                    }
                    if (++request.scriptCount === 2) {
                      request.scriptCount = 1;
                      _reconnectOnFailure();
                    }
                  };
                  script.onload = script.onreadystatechange = function() {
                    _debug("jsonp.onload");
                    if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                      script.clean();
                    }
                  };
                  script.onerror = function() {
                    _debug("jsonp.onerror");
                    request.scriptCount = 1;
                    script.clean();
                  };
                  head.insertBefore(script, head.firstChild);
                }
                window[callback] = function(msg) {
                  _debug("jsonp.window");
                  request.scriptCount = 0;
                  if (rq.reconnect && rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {
                    if (!rq.executeCallbackBeforeReconnect) {
                      _reconnect(_jqxhr, rq, rq.pollingInterval);
                    }
                    if (msg != null && typeof msg !== "string") {
                      try {
                        msg = msg.message;
                      } catch (err) {
                      }
                    }
                    var skipCallbackInvocation = _trackMessageSize(msg, rq, _response);
                    if (!skipCallbackInvocation) {
                      _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                    }
                    if (rq.executeCallbackBeforeReconnect) {
                      _reconnect(_jqxhr, rq, rq.pollingInterval);
                    }
                    _timeout(rq);
                  } else {
                    atmosphere.util.log(_request.logLevel, ["JSONP reconnect maximum try reached " + _request.requestCount]);
                    _onError(0, "maxRequest reached");
                  }
                };
                setTimeout(function() {
                  poll();
                }, 50);
              },
              abort: function() {
                if (script && script.clean) {
                  script.clean();
                }
              }
            };
            _jqxhr.open();
          }
          function _getWebSocket(location) {
            if (_request.webSocketImpl != null) {
              return _request.webSocketImpl;
            } else {
              if (window.WebSocket) {
                return new WebSocket(location);
              } else {
                return new MozWebSocket(location);
              }
            }
          }
          function _buildWebSocketUrl() {
            return _attachHeaders(_request, atmosphere.util.getAbsoluteURL(_request.webSocketUrl || _request.url)).replace(/^http/, "ws");
          }
          function _buildSSEUrl() {
            var url = _attachHeaders(_request);
            return url;
          }
          function _executeSSE(sseOpened) {
            _response.transport = "sse";
            var location = _buildSSEUrl();
            if (_canLog("debug")) {
              atmosphere.util.debug("Invoking executeSSE");
              atmosphere.util.debug("Using URL: " + location);
            }
            if (sseOpened && !_request.reconnect) {
              if (_sse != null) {
                _clearState();
              }
              return;
            }
            try {
              _sse = new EventSource(location, {
                withCredentials: _request.withCredentials
              });
            } catch (e2) {
              _onError(0, e2);
              _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
              return;
            }
            if (_request.connectTimeout > 0) {
              _request.id = setTimeout(function() {
                if (!sseOpened) {
                  _clearState();
                }
              }, _request.connectTimeout);
            }
            _sse.onopen = function() {
              _debug("sse.onopen");
              _timeout(_request);
              if (_canLog("debug")) {
                atmosphere.util.debug("SSE successfully opened");
              }
              if (!_request.enableProtocol) {
                if (!sseOpened) {
                  _open("opening", "sse", _request);
                } else {
                  _open("re-opening", "sse", _request);
                }
              } else if (_request.isReopen) {
                _request.isReopen = false;
                _open("re-opening", _request.transport, _request);
              }
              sseOpened = true;
              if (_request.method === "POST") {
                _response.state = "messageReceived";
                _push(_request.data);
              }
            };
            _sse.onmessage = function(message) {
              _debug("sse.onmessage");
              _timeout(_request);
              if (!_request.enableXDR && window.location.host && message.origin && message.origin !== window.location.protocol + "//" + window.location.host) {
                atmosphere.util.log(_request.logLevel, ["Origin was not " + window.location.protocol + "//" + window.location.host]);
                return;
              }
              _response.state = "messageReceived";
              _response.status = 200;
              message = message.data;
              var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
              if (!skipCallbackInvocation) {
                _invokeCallback();
                _response.responseBody = "";
                _response.messages = [];
              }
            };
            _sse.onerror = function() {
              _debug("sse.onerror");
              clearTimeout(_request.id);
              if (_request.heartbeatTimer) {
                clearTimeout(_request.heartbeatTimer);
              }
              if (_response.closedByClientTimeout) {
                return;
              }
              _invokeClose(sseOpened);
              _clearState();
              if (_abortingConnection) {
                atmosphere.util.log(_request.logLevel, ["SSE closed normally"]);
              } else if (!sseOpened) {
                _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
              } else if (_request.reconnect && _response.transport === "sse") {
                if (_requestCount++ < _request.maxReconnectOnClose) {
                  _open("re-connecting", _request.transport, _request);
                  if (_request.reconnectInterval > 0) {
                    var handleOnlineOffline = _request.handleOnlineOffline;
                    _request.handleOnlineOffline = false;
                    _request.reconnectId = setTimeout(function() {
                      _request.handleOnlineOffline = handleOnlineOffline;
                      _executeSSE(true);
                    }, _request.reconnectInterval);
                  } else {
                    _executeSSE(true);
                  }
                  _response.responseBody = "";
                  _response.messages = [];
                } else {
                  atmosphere.util.log(_request.logLevel, ["SSE reconnect maximum try reached " + _requestCount]);
                  _onError(0, "maxReconnectOnClose reached");
                }
              }
            };
          }
          function _executeWebSocket(webSocketOpened) {
            _response.transport = "websocket";
            var location = _buildWebSocketUrl(_request.url);
            if (_canLog("debug")) {
              atmosphere.util.debug("Invoking executeWebSocket, using URL: " + location);
            }
            if (webSocketOpened && !_request.reconnect) {
              if (_websocket != null) {
                _clearState();
              }
              return;
            }
            _websocket = _getWebSocket(location);
            if (_request.webSocketBinaryType != null) {
              _websocket.binaryType = _request.webSocketBinaryType;
            }
            if (_request.connectTimeout > 0) {
              _request.id = setTimeout(function() {
                if (!webSocketOpened) {
                  var _message = {
                    code: 1002,
                    reason: "Connection timeout after " + _request.connectTimeout + "ms.",
                    wasClean: false
                  };
                  var socket = _websocket;
                  try {
                    _clearState();
                  } catch (e2) {
                  }
                  socket.onclose(_message);
                }
              }, _request.connectTimeout);
            }
            _websocket.onopen = function() {
              if (_websocket == null) {
                this.close();
                if (_request.transport == "websocket")
                  _close();
                return;
              }
              _debug("websocket.onopen");
              if (!_request.enableProtocol || _request.connectTimeout <= 0)
                _timeout(_request);
              offline = false;
              if (_canLog("debug")) {
                atmosphere.util.debug("Websocket successfully opened");
              }
              var reopening = webSocketOpened;
              _websocket.canSendMessage = true;
              if (!_request.enableProtocol) {
                webSocketOpened = true;
                if (reopening) {
                  _open("re-opening", "websocket", _request);
                } else {
                  _open("opening", "websocket", _request);
                }
              }
              if (_request.method === "POST") {
                _response.state = "messageReceived";
                _websocket.send(_request.data);
              }
            };
            _websocket.onmessage = function(message) {
              if (_websocket == null) {
                this.close();
                if (_request.transport == "websocket")
                  _close();
                return;
              }
              _debug("websocket.onmessage");
              _timeout(_request);
              if (_request.enableProtocol) {
                webSocketOpened = true;
              }
              _response.state = "messageReceived";
              _response.status = 200;
              message = message.data;
              var isString = typeof message === "string";
              if (isString) {
                var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                if (!skipCallbackInvocation) {
                  _invokeCallback();
                  _response.responseBody = "";
                  _response.messages = [];
                }
              } else {
                message = _handleProtocol(_request, message);
                if (message === "")
                  return;
                _response.responseBody = message;
                _invokeCallback();
                _response.responseBody = null;
              }
            };
            _websocket.onerror = function() {
              _debug("websocket.onerror");
              clearTimeout(_request.id);
              if (_request.heartbeatTimer) {
                clearTimeout(_request.heartbeatTimer);
              }
              _response.error = true;
            };
            _websocket.onclose = function(message) {
              _debug("websocket.onclose");
              if (_response.transport !== "websocket")
                return;
              clearTimeout(_request.id);
              if (_response.state === "closed")
                return;
              var reason = message.reason;
              if (reason === "") {
                switch (message.code) {
                  case 1e3:
                    reason = "Normal closure; the connection successfully completed whatever purpose for which it was created.";
                    break;
                  case 1001:
                    reason = "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.";
                    break;
                  case 1002:
                    reason = "The endpoint is terminating the connection due to a protocol error.";
                    break;
                  case 1003:
                    reason = "The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).";
                    break;
                  case 1004:
                    reason = "The endpoint is terminating the connection because a data frame was received that is too large.";
                    break;
                  case 1005:
                    reason = "Unknown: no status code was provided even though one was expected.";
                    break;
                  case 1006:
                    reason = "Connection was closed abnormally (that is, with no close frame being sent).";
                    break;
                }
              }
              if (_canLog("warn")) {
                atmosphere.util.warn("Websocket closed, reason: " + reason + " - wasClean: " + message.wasClean);
              }
              if (_response.closedByClientTimeout || _request.handleOnlineOffline && offline) {
                if (_request.reconnectId) {
                  clearTimeout(_request.reconnectId);
                  delete _request.reconnectId;
                }
                return;
              }
              _invokeClose(webSocketOpened);
              _response.state = "closed";
              if (_abortingConnection) {
                atmosphere.util.log(_request.logLevel, ["Websocket closed normally"]);
              } else if (_response.error && _request.curWebsocketErrorRetries < _request.maxWebsocketErrorRetries && _requestCount + 1 < _request.maxReconnectOnClose) {
                _response.error = false;
                _request.curWebsocketErrorRetries++;
                _reconnectWebSocket();
              } else if ((_response.error || !webSocketOpened || _request.maxWebsocketErrorRetries === 0) && _request.fallbackTransport !== "websocket") {
                _response.error = false;
                _reconnectWithFallbackTransport("Websocket failed on first connection attempt. Downgrading to " + _request.fallbackTransport + " and resending");
              } else if (_request.reconnect) {
                _reconnectWebSocket();
              }
            };
            var ua = navigator.userAgent.toLowerCase();
            var isAndroid = ua.indexOf("android") > -1;
            if (isAndroid && _websocket.url === void 0) {
              _websocket.onclose({
                reason: "Android 4.1 does not support websockets.",
                wasClean: false
              });
            }
          }
          function _handleProtocol(request, message) {
            var nMessage = message;
            if (request.transport === "polling")
              return nMessage;
            if (request.enableProtocol && request.firstMessage && atmosphere.util.trim(message).length !== 0) {
              var pos = request.trackMessageLength ? 1 : 0;
              var messages = message.split(request.messageDelimiter);
              if (messages.length <= pos + 1) {
                return nMessage;
              }
              request.firstMessage = false;
              request.uuid = atmosphere.util.trim(messages[pos]);
              if (messages.length <= pos + 2) {
                atmosphere.util.log("error", ["Protocol data not sent by the server. If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side.Also note that atmosphere-runtime 2.2+ should be used."]);
              }
              _heartbeatInterval = parseInt(atmosphere.util.trim(messages[pos + 1]), 10);
              _heartbeatPadding = messages[pos + 2];
              if (request.transport !== "long-polling") {
                _triggerOpen(request);
              }
              uuid = request.uuid;
              nMessage = "";
              pos = request.trackMessageLength ? 4 : 3;
              if (messages.length > pos + 1) {
                for (var i4 = pos; i4 < messages.length; i4++) {
                  nMessage += messages[i4];
                  if (i4 + 1 !== messages.length) {
                    nMessage += request.messageDelimiter;
                  }
                }
              }
              if (request.ackInterval !== 0) {
                setTimeout(function() {
                  _push("...ACK...");
                }, request.ackInterval);
              }
            } else if (request.enableProtocol && request.firstMessage && atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
              atmosphere.util.log(_request.logLevel, ["Receiving unexpected data from IE"]);
            } else {
              _triggerOpen(request);
            }
            return nMessage;
          }
          function _timeout(_request2) {
            clearTimeout(_request2.id);
            if (_request2.timeout > 0 && _request2.transport !== "polling") {
              _request2.id = setTimeout(function() {
                _onClientTimeout(_request2);
                _disconnect();
                _clearState();
              }, _request2.timeout);
            }
          }
          function _onClientTimeout(_request2) {
            _response.closedByClientTimeout = true;
            _response.state = "closedByClient";
            _response.responseBody = "";
            _response.status = 408;
            _response.messages = [];
            _invokeCallback();
          }
          function _onError(code, reason) {
            _clearState();
            clearTimeout(_request.id);
            _response.state = "error";
            _response.reasonPhrase = reason;
            _response.responseBody = "";
            _response.status = code;
            _response.messages = [];
            _invokeCallback();
          }
          function _trackMessageSize(message, request, response) {
            message = _handleProtocol(request, message);
            if (message.length === 0)
              return true;
            response.responseBody = message;
            if (request.trackMessageLength) {
              message = response.partialMessage + message;
              var messages = [];
              var messageStart = message.indexOf(request.messageDelimiter);
              if (messageStart != -1) {
                while (messageStart !== -1) {
                  var str = message.substring(0, messageStart);
                  var messageLength = +str;
                  if (isNaN(messageLength)) {
                    response.partialMessage = "";
                    throw new Error('message length "' + str + '" is not a number');
                  }
                  messageStart += request.messageDelimiter.length;
                  if (messageStart + messageLength > message.length) {
                    messageStart = -1;
                  } else {
                    messages.push(message.substring(messageStart, messageStart + messageLength));
                    message = message.substring(messageStart + messageLength, message.length);
                    messageStart = message.indexOf(request.messageDelimiter);
                  }
                }
                response.partialMessage = message;
                if (messages.length !== 0) {
                  response.responseBody = messages.join(request.messageDelimiter);
                  response.messages = messages;
                  return false;
                } else {
                  response.responseBody = "";
                  response.messages = [];
                  return true;
                }
              }
            }
            response.responseBody = message;
            response.messages = [message];
            return false;
          }
          function _reconnectWebSocket() {
            _clearState();
            if (_requestCount++ < _request.maxReconnectOnClose) {
              _open("re-connecting", _request.transport, _request);
              if (_request.reconnectInterval > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _response.responseBody = "";
                  _response.messages = [];
                  _executeWebSocket(true);
                }, _request.reconnectInterval);
              } else {
                _response.responseBody = "";
                _response.messages = [];
                _executeWebSocket(true);
              }
            } else {
              atmosphere.util.log(_request.logLevel, ["Websocket reconnect maximum try reached " + _requestCount]);
              _onError(0, "maxReconnectOnClose reached");
            }
          }
          function _reconnectWithFallbackTransport(errorMessage) {
            atmosphere.util.log(_request.logLevel, [errorMessage]);
            _clearState();
            if (typeof _request.onTransportFailure !== "undefined") {
              _request.onTransportFailure(errorMessage, _request);
            } else if (typeof atmosphere.util.onTransportFailure !== "undefined") {
              atmosphere.util.onTransportFailure(errorMessage, _request);
            }
            if (_request.reconnect && _request.transport !== "none" || _request.transport == null) {
              _request.transport = _request.fallbackTransport;
              _request.method = _request.fallbackMethod;
              _response.transport = _request.fallbackTransport;
              _response.state = "";
              _request.fallbackTransport = "none";
              if (_request.reconnectInterval > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _execute();
                }, _request.reconnectInterval);
              } else {
                _execute();
              }
            } else {
              _onError(500, "Unable to reconnect with fallback transport");
            }
          }
          function _attachHeaders(request, url) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            if (url == null) {
              url = rq.url;
            }
            if (!rq.attachHeadersAsQueryString)
              return url;
            if (url.indexOf("X-Atmosphere-Framework") !== -1) {
              return url;
            }
            url += url.indexOf("?") !== -1 ? "&" : "?";
            url += "X-Atmosphere-tracking-id=" + rq.uuid;
            url += "&X-Atmosphere-Framework=" + atmosphere.version;
            url += "&X-Atmosphere-Transport=" + rq.transport;
            if (rq.trackMessageLength) {
              url += "&X-Atmosphere-TrackMessageSize=true";
            }
            if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
              url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
            }
            if (rq.contentType !== "") {
              url += "&Content-Type=" + (rq.transport === "websocket" ? rq.contentType : encodeURIComponent(rq.contentType));
            }
            if (rq.enableProtocol) {
              url += "&X-atmo-protocol=true";
            }
            atmosphere.util.each(rq.headers, function(name, value) {
              var h = atmosphere.util.isFunction(value) ? value.call(this, rq, request, _response) : value;
              if (h != null) {
                url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
              }
            });
            return url;
          }
          function _triggerOpen(rq) {
            if (!rq.isOpen) {
              rq.isOpen = true;
              _open("opening", rq.transport, rq);
            } else if (rq.isReopen) {
              rq.isReopen = false;
              _open("re-opening", rq.transport, rq);
            } else if (_response.state === "messageReceived" && (rq.transport === "jsonp" || rq.transport === "long-polling")) {
              _openAfterResume(_response);
            } else {
              return;
            }
            _startHeartbeat(rq);
          }
          function _startHeartbeat(rq) {
            if (rq.heartbeatTimer != null) {
              clearTimeout(rq.heartbeatTimer);
            }
            if (!isNaN(_heartbeatInterval) && _heartbeatInterval > 0) {
              var _pushHeartbeat = function() {
                if (_canLog("debug")) {
                  atmosphere.util.debug("Sending heartbeat");
                }
                _push(_heartbeatPadding);
                rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
              };
              rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
            }
          }
          function _executeRequest(request) {
            var rq = _request;
            if (request != null || typeof request !== "undefined") {
              rq = request;
            }
            rq.lastIndex = 0;
            rq.readyState = 0;
            if (rq.transport === "jsonp" || rq.enableXDR && atmosphere.util.checkCORSSupport()) {
              _jsonp(rq);
              return;
            }
            if (atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
              if (rq.transport === "streaming") {
                if (rq.enableXDR && window.XDomainRequest) {
                  _ieXDR(rq);
                } else {
                  _ieStreaming(rq);
                }
                return;
              }
              if (rq.enableXDR && window.XDomainRequest) {
                _ieXDR(rq);
                return;
              }
            }
            var reconnectFExec = function(force) {
              rq.lastIndex = 0;
              _requestCount++;
              if (force || rq.reconnect && _requestCount <= rq.maxReconnectOnClose) {
                var delay = force ? 0 : request.reconnectInterval;
                _response.ffTryingReconnect = true;
                _open("re-connecting", request.transport, request);
                _reconnect(ajaxRequest, rq, delay);
              } else {
                _onError(0, "maxReconnectOnClose reached");
              }
            };
            var reconnectF = function(force) {
              if (atmosphere._beforeUnloadState) {
                atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag");
                setTimeout(function() {
                  reconnectFExec(force);
                }, 5e3);
              } else {
                reconnectFExec(force);
              }
            };
            var disconnected = function() {
              _response.errorHandled = true;
              _clearState();
              reconnectF(false);
            };
            if (rq.force || rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
              rq.force = false;
              var ajaxRequest = atmosphere.util.xhr();
              ajaxRequest.hasData = false;
              _doRequest(ajaxRequest, rq, true);
              if (rq.suspend) {
                _activeRequest = ajaxRequest;
              }
              if (rq.transport !== "polling") {
                _response.transport = rq.transport;
                ajaxRequest.onabort = function() {
                  _debug("ajaxrequest.onabort");
                  _invokeClose(true);
                };
                ajaxRequest.onerror = function() {
                  _debug("ajaxrequest.onerror");
                  _response.error = true;
                  _response.ffTryingReconnect = true;
                  try {
                    _response.status = XMLHttpRequest.status;
                  } catch (e2) {
                    _response.status = 500;
                  }
                  if (!_response.status) {
                    _response.status = 500;
                  }
                  if (!_response.errorHandled) {
                    _clearState();
                    reconnectF(false);
                  }
                };
              }
              ajaxRequest.onreadystatechange = function() {
                _debug("ajaxRequest.onreadystatechange, new state: " + ajaxRequest.readyState);
                if (_abortingConnection) {
                  _debug("onreadystatechange has been ignored due to _abortingConnection flag");
                  return;
                }
                _response.error = false;
                var skipCallbackInvocation = false;
                var update = false;
                if (rq.transport === "streaming" && rq.readyState > 2 && ajaxRequest.readyState === 4) {
                  _clearState();
                  reconnectF(false);
                  return;
                }
                rq.readyState = ajaxRequest.readyState;
                if (rq.transport === "streaming" && ajaxRequest.readyState >= 3) {
                  update = true;
                } else if (rq.transport === "long-polling" && ajaxRequest.readyState === 4) {
                  update = true;
                }
                _timeout(_request);
                if (rq.transport !== "polling") {
                  var status = 200;
                  if (ajaxRequest.readyState === 4) {
                    status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
                  }
                  if (!rq.reconnectOnServerError && (status >= 300 && status < 600)) {
                    _onError(status, ajaxRequest.statusText);
                    return;
                  }
                  if (status >= 300 || status === 0) {
                    if (!rq.isOpen && _canLog("warn")) {
                      atmosphere.util.warn(rq.transport + " connection failed with status: " + status + " " + (ajaxRequest.statusText || "Unable to connect"));
                    }
                    disconnected();
                    return;
                  }
                  if ((!rq.enableProtocol || !request.firstMessage) && (ajaxRequest.readyState === 2 || ajaxRequest.readyState > 2 && !rq.isOpen)) {
                    if (atmosphere.util.browser.mozilla && _response.ffTryingReconnect) {
                      _response.ffTryingReconnect = false;
                      setTimeout(function() {
                        if (!_response.ffTryingReconnect) {
                          _triggerOpen(rq);
                        }
                      }, 500);
                    } else {
                      _triggerOpen(rq);
                    }
                  }
                } else if (ajaxRequest.readyState === 4) {
                  update = true;
                }
                if (update) {
                  var responseText = ajaxRequest.responseText;
                  _response.errorHandled = false;
                  if (rq.transport === "long-polling" && atmosphere.util.trim(responseText).length === 0) {
                    if (!ajaxRequest.hasData) {
                      reconnectF(true);
                    } else {
                      ajaxRequest.hasData = false;
                    }
                    return;
                  }
                  ajaxRequest.hasData = true;
                  _readHeaders(ajaxRequest, _request);
                  if (rq.transport === "streaming") {
                    if (!atmosphere.util.browser.opera) {
                      var message = responseText.substring(rq.lastIndex, responseText.length);
                      skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                      rq.lastIndex = responseText.length;
                      if (skipCallbackInvocation) {
                        return;
                      }
                    } else {
                      atmosphere.util.iterate(function() {
                        if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                          try {
                            _response.status = ajaxRequest.status;
                            _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());
                            _readHeaders(ajaxRequest, _request);
                          } catch (e2) {
                            _response.status = 404;
                          }
                          _timeout(_request);
                          _response.state = "messageReceived";
                          var message2 = ajaxRequest.responseText.substring(rq.lastIndex);
                          rq.lastIndex = ajaxRequest.responseText.length;
                          skipCallbackInvocation = _trackMessageSize(message2, rq, _response);
                          if (!skipCallbackInvocation) {
                            _invokeCallback();
                          }
                          if (_verifyStreamingLength(ajaxRequest, rq)) {
                            _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                            return;
                          }
                        } else if (_response.status > 400) {
                          rq.lastIndex = ajaxRequest.responseText.length;
                          return false;
                        }
                      }, 0);
                    }
                  } else {
                    skipCallbackInvocation = _trackMessageSize(responseText, rq, _response);
                  }
                  var closeStream = _verifyStreamingLength(ajaxRequest, rq);
                  try {
                    _response.status = ajaxRequest.status;
                    _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());
                    _readHeaders(ajaxRequest, rq);
                  } catch (e2) {
                    _response.status = 404;
                  }
                  if (rq.suspend) {
                    _response.state = _response.status === 0 ? "closed" : "messageReceived";
                  } else {
                    _response.state = "messagePublished";
                  }
                  var isAllowedToReconnect = !closeStream && request.transport !== "streaming" && request.transport !== "polling";
                  if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
                    _reconnect(ajaxRequest, rq, rq.pollingInterval);
                  }
                  if (_response.responseBody.length !== 0 && !skipCallbackInvocation)
                    _invokeCallback();
                  if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
                    _reconnect(ajaxRequest, rq, rq.pollingInterval);
                  }
                  if (closeStream) {
                    _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                  }
                }
              };
              try {
                ajaxRequest.send(rq.data);
                _subscribed = true;
              } catch (e2) {
                atmosphere.util.log(rq.logLevel, ["Unable to connect to " + rq.url]);
                _onError(0, e2);
              }
            } else {
              if (rq.logLevel === "debug") {
                atmosphere.util.log(rq.logLevel, ["Max re-connection reached."]);
              }
              _onError(0, "maxRequest reached");
            }
          }
          function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
            _response.messages = [];
            rq.isReopen = true;
            _close();
            _abortingConnection = false;
            _reconnect(ajaxRequest, rq, 500);
          }
          function _doRequest(ajaxRequest, request, create) {
            var url = request.url;
            if (request.dispatchUrl != null && request.method === "POST") {
              url += request.dispatchUrl;
            }
            url = _attachHeaders(request, url);
            url = atmosphere.util.prepareURL(url);
            if (create) {
              ajaxRequest.open(request.method, url, true);
              if (request.connectTimeout > 0) {
                request.id = setTimeout(function() {
                  if (request.requestCount === 0) {
                    _clearState();
                    _prepareCallback("Connect timeout", "closed", 200, request.transport);
                  }
                }, request.connectTimeout);
              }
            }
            if (_request.withCredentials && _request.transport !== "websocket") {
              if ("withCredentials" in ajaxRequest) {
                ajaxRequest.withCredentials = true;
              }
            }
            if (!_request.dropHeaders) {
              ajaxRequest.setRequestHeader("X-Atmosphere-Framework", atmosphere.version);
              ajaxRequest.setRequestHeader("X-Atmosphere-Transport", request.transport);
              if (request.heartbeat !== null && request.heartbeat.server !== null) {
                ajaxRequest.setRequestHeader("X-Heartbeat-Server", ajaxRequest.heartbeat.server);
              }
              if (request.trackMessageLength) {
                ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
              }
              ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);
              atmosphere.util.each(request.headers, function(name, value) {
                var h = atmosphere.util.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
                if (h != null) {
                  ajaxRequest.setRequestHeader(name, h);
                }
              });
            }
            if (request.contentType !== "") {
              ajaxRequest.setRequestHeader("Content-Type", request.contentType);
            }
          }
          function _reconnect(ajaxRequest, request, delay) {
            if (_response.closedByClientTimeout) {
              return;
            }
            if (request.reconnect || request.suspend && _subscribed) {
              var status = 0;
              if (ajaxRequest && ajaxRequest.readyState > 1) {
                status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
              }
              _response.status = status === 0 ? 204 : status;
              _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";
              clearTimeout(request.id);
              if (request.reconnectId) {
                clearTimeout(request.reconnectId);
                delete request.reconnectId;
              }
              if (delay > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _executeRequest(request);
                }, delay);
              } else {
                _executeRequest(request);
              }
            }
          }
          function _tryingToReconnect(response) {
            response.state = "re-connecting";
            _invokeFunction(response);
          }
          function _openAfterResume(response) {
            response.state = "openAfterResume";
            _invokeFunction(response);
            response.state = "messageReceived";
          }
          function _ieXDR(request) {
            if (request.transport !== "polling") {
              _ieStream = _configureXDR(request);
              _ieStream.open();
            } else {
              _configureXDR(request).open();
            }
          }
          function _configureXDR(request) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            var transport = rq.transport;
            var lastIndex = 0;
            var xdr = new window.XDomainRequest();
            var reconnect = function() {
              if (rq.transport === "long-polling" && (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest))) {
                xdr.status = 200;
                _ieXDR(rq);
              }
            };
            var rewriteURL = rq.rewriteURL || function(url) {
              var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);
              switch (match && match[1]) {
                case "JSESSIONID":
                  return url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + match[2] + "$1");
                case "PHPSESSID":
                  return url.replace(/\?PHPSESSID=[^&]*&?|\?|$/, "?PHPSESSID=" + match[2] + "&").replace(/&$/, "");
              }
              return url;
            };
            xdr.onprogress = function() {
              handle(xdr);
            };
            xdr.onerror = function() {
              if (rq.transport !== "polling") {
                _clearState();
                if (_requestCount++ < rq.maxReconnectOnClose) {
                  if (rq.reconnectInterval > 0) {
                    rq.reconnectId = setTimeout(function() {
                      _open("re-connecting", request.transport, request);
                      _ieXDR(rq);
                    }, rq.reconnectInterval);
                  } else {
                    _open("re-connecting", request.transport, request);
                    _ieXDR(rq);
                  }
                } else {
                  _onError(0, "maxReconnectOnClose reached");
                }
              }
            };
            xdr.onload = function() {
            };
            var handle = function(xdr2) {
              clearTimeout(rq.id);
              var message = xdr2.responseText;
              message = message.substring(lastIndex);
              lastIndex += message.length;
              if (transport !== "polling") {
                _timeout(rq);
                var skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                if (transport === "long-polling" && atmosphere.util.trim(message).length === 0)
                  return;
                if (rq.executeCallbackBeforeReconnect) {
                  reconnect();
                }
                if (!skipCallbackInvocation) {
                  _prepareCallback(_response.responseBody, "messageReceived", 200, transport);
                }
                if (!rq.executeCallbackBeforeReconnect) {
                  reconnect();
                }
              }
            };
            return {
              open: function() {
                var url = rq.url;
                if (rq.dispatchUrl != null) {
                  url += rq.dispatchUrl;
                }
                url = _attachHeaders(rq, url);
                xdr.open(rq.method, rewriteURL(url));
                if (rq.method === "GET") {
                  xdr.send();
                } else {
                  xdr.send(rq.data);
                }
                if (rq.connectTimeout > 0) {
                  rq.id = setTimeout(function() {
                    if (rq.requestCount === 0) {
                      _clearState();
                      _prepareCallback("Connect timeout", "closed", 200, rq.transport);
                    }
                  }, rq.connectTimeout);
                }
              },
              close: function() {
                xdr.abort();
              }
            };
          }
          function _ieStreaming(request) {
            _ieStream = _configureIE(request);
            _ieStream.open();
          }
          function _configureIE(request) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            var stop;
            var doc = new window.ActiveXObject("htmlfile");
            doc.open();
            doc.close();
            var url = rq.url;
            if (rq.dispatchUrl != null) {
              url += rq.dispatchUrl;
            }
            if (rq.transport !== "polling") {
              _response.transport = rq.transport;
            }
            return {
              open: function() {
                var iframe = doc.createElement("iframe");
                url = _attachHeaders(rq);
                if (rq.data !== "") {
                  url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
                }
                url = atmosphere.util.prepareURL(url);
                iframe.src = url;
                doc.body.appendChild(iframe);
                var cdoc = iframe.contentDocument || iframe.contentWindow.document;
                stop = atmosphere.util.iterate(function() {
                  try {
                    if (!cdoc.firstChild) {
                      return;
                    }
                    var res = cdoc.body ? cdoc.body.lastChild : cdoc;
                    if (res.omgThisIsBroken) {
                    }
                    var readResponse = function() {
                      var clone = res.cloneNode(true);
                      clone.appendChild(cdoc.createTextNode("."));
                      var text = clone.innerText;
                      text = text.substring(0, text.length - 1);
                      return text;
                    };
                    if (!cdoc.body || !cdoc.body.firstChild || cdoc.body.firstChild.nodeName.toLowerCase() !== "pre") {
                      var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                      var script = cdoc.createElement("script");
                      script.text = "document.write('<plaintext>')";
                      head.insertBefore(script, head.firstChild);
                      head.removeChild(script);
                      res = cdoc.body.lastChild;
                    }
                    if (rq.closed) {
                      rq.isReopen = true;
                    }
                    stop = atmosphere.util.iterate(function() {
                      var text = readResponse();
                      if (text.length > rq.lastIndex) {
                        _timeout(_request);
                        _response.status = 200;
                        _response.error = false;
                        res.innerText = "";
                        var skipCallbackInvocation = _trackMessageSize(text, rq, _response);
                        if (skipCallbackInvocation) {
                          return "";
                        }
                        _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                      }
                      rq.lastIndex = 0;
                      if (cdoc.readyState === "complete") {
                        _invokeClose(true);
                        _open("re-connecting", rq.transport, rq);
                        if (rq.reconnectInterval > 0) {
                          rq.reconnectId = setTimeout(function() {
                            _ieStreaming(rq);
                          }, rq.reconnectInterval);
                        } else {
                          _ieStreaming(rq);
                        }
                        return false;
                      }
                    }, null);
                    return false;
                  } catch (err) {
                    _response.error = true;
                    _open("re-connecting", rq.transport, rq);
                    if (_requestCount++ < rq.maxReconnectOnClose) {
                      if (rq.reconnectInterval > 0) {
                        rq.reconnectId = setTimeout(function() {
                          _ieStreaming(rq);
                        }, rq.reconnectInterval);
                      } else {
                        _ieStreaming(rq);
                      }
                    } else {
                      _onError(0, "maxReconnectOnClose reached");
                    }
                    doc.execCommand("Stop");
                    doc.close();
                    return false;
                  }
                });
              },
              close: function() {
                if (stop) {
                  stop();
                }
                doc.execCommand("Stop");
                _invokeClose(true);
              }
            };
          }
          function _push(message) {
            if (_localStorageService != null) {
              _pushLocal(message);
            } else if (_activeRequest != null || _sse != null) {
              _pushAjaxMessage(message);
            } else if (_ieStream != null) {
              _pushIE(message);
            } else if (_jqxhr != null) {
              _pushJsonp(message);
            } else if (_websocket != null) {
              _pushWebSocket(message);
            } else {
              _onError(0, "No suspended connection available");
              atmosphere.util.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data");
            }
          }
          function _pushOnClose(message, rq) {
            if (!rq) {
              rq = _getPushRequest(message);
            }
            rq.transport = "polling";
            rq.method = "GET";
            rq.withCredentials = false;
            rq.reconnect = false;
            rq.force = true;
            rq.suspend = false;
            rq.timeout = 1e3;
            if (_request.unloadBackwardCompat) {
              _executeRequest(rq);
            } else {
              navigator.sendBeacon(rq.url, rq.data);
            }
          }
          function _pushLocal(message) {
            _localStorageService.send(message);
          }
          function _intraPush(message) {
            if (message.length === 0)
              return;
            try {
              if (_localStorageService) {
                _localStorageService.localSend(message);
              } else if (_storageService) {
                _storageService.signal("localMessage", JSON.stringify({
                  id: guid2,
                  event: message
                }));
              }
            } catch (err) {
              atmosphere.util.error(err);
            }
          }
          function _pushAjaxMessage(message) {
            var rq = _getPushRequest(message);
            _executeRequest(rq);
          }
          function _pushIE(message) {
            if (_request.enableXDR && atmosphere.util.checkCORSSupport()) {
              var rq = _getPushRequest(message);
              rq.reconnect = false;
              _jsonp(rq);
            } else {
              _pushAjaxMessage(message);
            }
          }
          function _pushJsonp(message) {
            _pushAjaxMessage(message);
          }
          function _getStringMessage(message) {
            var msg = message;
            if (typeof msg === "object") {
              msg = message.data;
            }
            return msg;
          }
          function _getPushRequest(message) {
            var msg = _getStringMessage(message);
            var rq = {
              connected: false,
              timeout: 6e4,
              method: "POST",
              url: _request.url,
              contentType: _request.contentType,
              headers: _request.headers,
              reconnect: true,
              callback: null,
              data: msg,
              suspend: false,
              maxRequest: -1,
              logLevel: "info",
              requestCount: 0,
              withCredentials: _request.withCredentials,
              transport: "polling",
              isOpen: true,
              attachHeadersAsQueryString: true,
              enableXDR: _request.enableXDR,
              uuid: _request.uuid,
              dispatchUrl: _request.dispatchUrl,
              enableProtocol: false,
              messageDelimiter: "|",
              trackMessageLength: _request.trackMessageLength,
              maxReconnectOnClose: _request.maxReconnectOnClose,
              heartbeatTimer: _request.heartbeatTimer,
              heartbeat: _request.heartbeat
            };
            if (typeof message === "object") {
              rq = atmosphere.util.extend(rq, message);
            }
            return rq;
          }
          function _pushWebSocket(message) {
            var msg = atmosphere.util.isBinary(message) ? message : _getStringMessage(message);
            var data;
            try {
              if (_request.dispatchUrl != null) {
                data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
              } else {
                data = msg;
              }
              if (!_websocket.canSendMessage) {
                atmosphere.util.error("WebSocket not connected.");
                return;
              }
              _websocket.send(data);
            } catch (e2) {
              _websocket.onclose = function() {
              };
              _clearState();
              _reconnectWithFallbackTransport("Websocket failed. Downgrading to " + _request.fallbackTransport + " and resending " + message);
              _pushAjaxMessage(message);
            }
          }
          function _localMessage(message) {
            var m2 = JSON.parse(message);
            if (m2.id !== guid2) {
              if (typeof _request.onLocalMessage !== "undefined") {
                _request.onLocalMessage(m2.event);
              } else if (typeof atmosphere.util.onLocalMessage !== "undefined") {
                atmosphere.util.onLocalMessage(m2.event);
              }
            }
          }
          function _prepareCallback(messageBody, state, errorCode, transport) {
            _response.responseBody = messageBody;
            _response.transport = transport;
            _response.status = errorCode;
            _response.state = state;
            _invokeCallback();
          }
          function _readHeaders(xdr, request) {
            if (!request.readResponsesHeaders) {
              if (!request.enableProtocol) {
                request.uuid = guid2;
              }
            } else {
              try {
                var tempUUID = xdr.getResponseHeader("X-Atmosphere-tracking-id");
                if (tempUUID && tempUUID != null) {
                  request.uuid = tempUUID.split(" ").pop();
                }
              } catch (e2) {
              }
            }
          }
          function _invokeFunction(response) {
            _f(response, _request);
            _f(response, atmosphere.util);
          }
          function _f(response, f3) {
            switch (response.state) {
              case "messageReceived":
                _debug("Firing onMessage");
                _requestCount = 0;
                if (typeof f3.onMessage !== "undefined")
                  f3.onMessage(response);
                if (typeof f3.onmessage !== "undefined")
                  f3.onmessage(response);
                break;
              case "error":
                var dbgReasonPhrase = typeof response.reasonPhrase != "undefined" ? response.reasonPhrase : "n/a";
                _debug("Firing onError, reasonPhrase: " + dbgReasonPhrase);
                if (typeof f3.onError !== "undefined")
                  f3.onError(response);
                if (typeof f3.onerror !== "undefined")
                  f3.onerror(response);
                break;
              case "opening":
                delete _request.closed;
                _debug("Firing onOpen");
                if (typeof f3.onOpen !== "undefined")
                  f3.onOpen(response);
                if (typeof f3.onopen !== "undefined")
                  f3.onopen(response);
                break;
              case "messagePublished":
                _debug("Firing messagePublished");
                if (typeof f3.onMessagePublished !== "undefined")
                  f3.onMessagePublished(response);
                break;
              case "re-connecting":
                _debug("Firing onReconnect");
                if (typeof f3.onReconnect !== "undefined")
                  f3.onReconnect(_request, response);
                break;
              case "closedByClient":
                _debug("Firing closedByClient");
                if (typeof f3.onClientTimeout !== "undefined")
                  f3.onClientTimeout(_request);
                break;
              case "re-opening":
                delete _request.closed;
                _debug("Firing onReopen");
                if (typeof f3.onReopen !== "undefined")
                  f3.onReopen(_request, response);
                break;
              case "fail-to-reconnect":
                _debug("Firing onFailureToReconnect");
                if (typeof f3.onFailureToReconnect !== "undefined")
                  f3.onFailureToReconnect(_request, response);
                break;
              case "unsubscribe":
              case "closed":
                var closed = typeof _request.closed !== "undefined" ? _request.closed : false;
                if (!closed) {
                  _debug("Firing onClose (" + response.state + " case)");
                  if (typeof f3.onClose !== "undefined") {
                    f3.onClose(response);
                  }
                  if (typeof f3.onclose !== "undefined") {
                    f3.onclose(response);
                  }
                } else {
                  _debug("Request already closed, not firing onClose (" + response.state + " case)");
                }
                _request.closed = true;
                break;
              case "openAfterResume":
                if (typeof f3.onOpenAfterResume !== "undefined")
                  f3.onOpenAfterResume(_request);
                break;
            }
          }
          function _invokeClose(wasOpen) {
            if (_response.state !== "closed") {
              _response.state = "closed";
              _response.responseBody = "";
              _response.messages = [];
              _response.status = !wasOpen ? 501 : 200;
              _invokeCallback();
            }
          }
          function _invokeCallback() {
            var call = function(index, func) {
              func(_response);
            };
            if (_localStorageService == null && _localSocketF != null) {
              _localSocketF(_response.responseBody);
            }
            _request.reconnect = _request.mrequest;
            var isString = typeof _response.responseBody === "string";
            var messages = isString && _request.trackMessageLength ? _response.messages.length > 0 ? _response.messages : [""] : new Array(
              _response.responseBody
            );
            for (var i4 = 0; i4 < messages.length; i4++) {
              if (messages.length > 1 && messages[i4].length === 0) {
                continue;
              }
              _response.responseBody = isString ? atmosphere.util.trim(messages[i4]) : messages[i4];
              if (_localStorageService == null && _localSocketF != null) {
                _localSocketF(_response.responseBody);
              }
              if (_response.state === "messageReceived") {
                if (_response.responseBody.length === 0) {
                  continue;
                } else if (isString && _heartbeatPadding === _response.responseBody) {
                  _requestCount = 0;
                  continue;
                }
              }
              _invokeFunction(_response);
              if (callbacks.length > 0) {
                if (_canLog("debug")) {
                  atmosphere.util.debug("Invoking " + callbacks.length + " global callbacks: " + _response.state);
                }
                try {
                  atmosphere.util.each(callbacks, call);
                } catch (e2) {
                  atmosphere.util.log(_request.logLevel, ["Callback exception" + e2]);
                }
              }
              if (typeof _request.callback === "function") {
                if (_canLog("debug")) {
                  atmosphere.util.debug("Invoking request callbacks");
                }
                try {
                  _request.callback(_response);
                } catch (e2) {
                  atmosphere.util.log(_request.logLevel, ["Callback exception" + e2]);
                }
              }
            }
          }
          this.subscribe = function(options2) {
            _subscribe(options2);
            _execute();
          };
          this.execute = function() {
            _execute();
          };
          this.close = function() {
            _close();
          };
          this.disconnect = function() {
            _disconnect();
          };
          this.getUrl = function() {
            return _request.url;
          };
          this.push = function(message, dispatchUrl) {
            if (dispatchUrl != null) {
              var originalDispatchUrl = _request.dispatchUrl;
              _request.dispatchUrl = dispatchUrl;
              _push(message);
              _request.dispatchUrl = originalDispatchUrl;
            } else {
              _push(message);
            }
          };
          this.getUUID = function() {
            return _request.uuid;
          };
          this.pushLocal = function(message) {
            _intraPush(message);
          };
          this.enableProtocol = function() {
            return _request.enableProtocol;
          };
          this.init = function() {
            _init();
          };
          this.request = _request;
          this.response = _response;
        }
      };
      atmosphere.subscribe = function(url, callback, request) {
        if (typeof callback === "function") {
          atmosphere.addCallback(callback);
        }
        if (typeof url !== "string") {
          request = url;
        } else {
          request.url = url;
        }
        uuid = typeof request !== "undefined" && typeof request.uuid !== "undefined" ? request.uuid : 0;
        var rq = new atmosphere.AtmosphereRequest(request);
        rq.execute();
        requests[requests.length] = rq;
        return rq;
      };
      atmosphere.unsubscribe = function() {
        if (requests.length > 0) {
          var requestsClone = [].concat(requests);
          for (var i4 = 0; i4 < requestsClone.length; i4++) {
            var rq = requestsClone[i4];
            rq.close();
            clearTimeout(rq.response.request.id);
            if (rq.heartbeatTimer) {
              clearTimeout(rq.heartbeatTimer);
            }
          }
        }
        requests = [];
        callbacks = [];
      };
      atmosphere.unsubscribeUrl = function(url) {
        var idx = -1;
        if (requests.length > 0) {
          for (var i4 = 0; i4 < requests.length; i4++) {
            var rq = requests[i4];
            if (rq.getUrl() === url) {
              rq.close();
              clearTimeout(rq.response.request.id);
              if (rq.heartbeatTimer) {
                clearTimeout(rq.heartbeatTimer);
              }
              idx = i4;
              break;
            }
          }
        }
        if (idx >= 0) {
          requests.splice(idx, 1);
        }
      };
      atmosphere.addCallback = function(func) {
        if (atmosphere.util.inArray(func, callbacks) === -1) {
          callbacks.push(func);
        }
      };
      atmosphere.removeCallback = function(func) {
        var index = atmosphere.util.inArray(func, callbacks);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      };
      atmosphere.util = {
        browser: {},
        parseHeaders: function(headerString) {
          var match, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, headers = {};
          while (match = rheaders.exec(headerString)) {
            headers[match[1]] = match[2];
          }
          return headers;
        },
        now: function() {
          return (/* @__PURE__ */ new Date()).getTime();
        },
        isArray: function(array) {
          return Object.prototype.toString.call(array) === "[object Array]";
        },
        inArray: function(elem, array) {
          if (!Array.prototype.indexOf) {
            var len = array.length;
            for (var i4 = 0; i4 < len; ++i4) {
              if (array[i4] === elem) {
                return i4;
              }
            }
            return -1;
          }
          return array.indexOf(elem);
        },
        isBinary: function(data) {
          return /^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(data));
        },
        isFunction: function(fn) {
          return Object.prototype.toString.call(fn) === "[object Function]";
        },
        getAbsoluteURL: function(url) {
          if (typeof document.createElement === "undefined") {
            return url;
          }
          var div = document.createElement("div");
          div.innerHTML = '<a href="' + url + '"></a>';
          var ua = window.navigator.userAgent;
          if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0) {
            return atmosphere.util.fixedEncodeURI(decodeURI(div.firstChild.href));
          }
          return div.firstChild.href;
        },
        fixedEncodeURI: function(str) {
          return encodeURI(str).replace(/%5B/g, "[").replace(/%5D/g, "]");
        },
        prepareURL: function(url) {
          var ts = atmosphere.util.now();
          var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);
          return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
        },
        trim: function(str) {
          if (!String.prototype.trim) {
            return str.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, "").replace(/\s+/g, " ");
          } else {
            return str.toString().trim();
          }
        },
        param: function(params) {
          var prefix, s2 = [];
          function add(key, value) {
            value = atmosphere.util.isFunction(value) ? value() : value == null ? "" : value;
            s2.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
          }
          function buildParams(prefix2, obj) {
            var name;
            if (atmosphere.util.isArray(obj)) {
              atmosphere.util.each(obj, function(i4, v) {
                if (/\[\]$/.test(prefix2)) {
                  add(prefix2, v);
                } else {
                  buildParams(prefix2 + "[" + (typeof v === "object" ? i4 : "") + "]", v);
                }
              });
            } else if (Object.prototype.toString.call(obj) === "[object Object]") {
              for (name in obj) {
                buildParams(prefix2 + "[" + name + "]", obj[name]);
              }
            } else {
              add(prefix2, obj);
            }
          }
          for (prefix in params) {
            buildParams(prefix, params[prefix]);
          }
          return s2.join("&").replace(/%20/g, "+");
        },
        storage: function() {
          try {
            return !!(window.localStorage && window.StorageEvent);
          } catch (e2) {
            return false;
          }
        },
        iterate: function(fn, interval) {
          var timeoutId;
          interval = interval || 0;
          (function loop() {
            timeoutId = setTimeout(function() {
              if (fn() === false) {
                return;
              }
              loop();
            }, interval);
          })();
          return function() {
            clearTimeout(timeoutId);
          };
        },
        each: function(obj, callback, args) {
          if (!obj)
            return;
          var value, i4 = 0, length = obj.length, isArray = atmosphere.util.isArray(obj);
          if (args) {
            if (isArray) {
              for (; i4 < length; i4++) {
                value = callback.apply(obj[i4], args);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i4 in obj) {
                value = callback.apply(obj[i4], args);
                if (value === false) {
                  break;
                }
              }
            }
          } else {
            if (isArray) {
              for (; i4 < length; i4++) {
                value = callback.call(obj[i4], i4, obj[i4]);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i4 in obj) {
                value = callback.call(obj[i4], i4, obj[i4]);
                if (value === false) {
                  break;
                }
              }
            }
          }
          return obj;
        },
        extend: function(target) {
          var i4, options, name;
          for (i4 = 1; i4 < arguments.length; i4++) {
            if ((options = arguments[i4]) != null) {
              for (name in options) {
                target[name] = options[name];
              }
            }
          }
          return target;
        },
        on: function(elem, type, fn) {
          if (elem.addEventListener) {
            elem.addEventListener(type, fn, false);
          } else if (elem.attachEvent) {
            elem.attachEvent("on" + type, fn);
          }
        },
        off: function(elem, type, fn) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, fn, false);
          } else if (elem.detachEvent) {
            elem.detachEvent("on" + type, fn);
          }
        },
        log: function(level, args) {
          if (window.console) {
            var logger = window.console[level];
            if (typeof logger === "function") {
              logger.apply(window.console, args);
            }
          }
        },
        warn: function() {
          atmosphere.util.log("warn", arguments);
        },
        info: function() {
          atmosphere.util.log("info", arguments);
        },
        debug: function() {
          atmosphere.util.log("debug", arguments);
        },
        error: function() {
          atmosphere.util.log("error", arguments);
        },
        xhr: function() {
          try {
            return new window.XMLHttpRequest();
          } catch (e1) {
            try {
              return new window.ActiveXObject("Microsoft.XMLHTTP");
            } catch (e2) {
            }
          }
        },
        checkCORSSupport: function() {
          if (atmosphere.util.browser.msie && !window.XDomainRequest && +atmosphere.util.browser.version.split(".")[0] < 11) {
            return true;
          } else if (atmosphere.util.browser.opera && +atmosphere.util.browser.version.split(".") < 12) {
            return true;
          } else if (atmosphere.util.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
            return true;
          } else if (atmosphere.util.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
            return true;
          }
          var ua = navigator.userAgent.toLowerCase();
          var androidVersionMatches = ua.match(/.+android ([0-9]{1,2})/i), majorVersion = parseInt(androidVersionMatches && androidVersionMatches[0] || -1, 10);
          if (!isNaN(majorVersion) && majorVersion > -1 && majorVersion < 3) {
            return true;
          }
          return false;
        }
      };
      guid = atmosphere.util.now();
      (function() {
        var ua = navigator.userAgent.toLowerCase(), match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) || ua.indexOf("android") < 0 && /version\/(.+) (safari)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
        if (match[2] === "safari") {
          match[2] = match[1];
          match[1] = "safari";
        }
        atmosphere.util.browser[match[1] || ""] = true;
        atmosphere.util.browser.version = match[2] || "0";
        atmosphere.util.browser.vmajor = atmosphere.util.browser.version.split(".")[0];
        if (atmosphere.util.browser.trident) {
          atmosphere.util.browser.msie = true;
        }
        if (atmosphere.util.browser.msie || atmosphere.util.browser.mozilla && +atmosphere.util.browser.version.split(".")[0] === 1) {
          atmosphere.util.storage = false;
        }
      })();
      atmosphere.callbacks = {
        unload: function() {
          atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: unload event");
          atmosphere.unsubscribe();
        },
        beforeUnload: function() {
          atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: beforeunload event");
          atmosphere._beforeUnloadState = true;
          setTimeout(function() {
            atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: beforeunload event timeout reached. Reset _beforeUnloadState flag");
            atmosphere._beforeUnloadState = false;
          }, 5e3);
        },
        offline: function() {
          atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: offline event");
          offline = true;
          if (requests.length > 0) {
            var requestsClone = [].concat(requests);
            for (var i4 = 0; i4 < requestsClone.length; i4++) {
              var rq = requestsClone[i4];
              if (rq.request.handleOnlineOffline) {
                rq.close();
                clearTimeout(rq.response.request.id);
                if (rq.heartbeatTimer) {
                  clearTimeout(rq.heartbeatTimer);
                }
              }
            }
          }
        },
        online: function() {
          atmosphere.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: online event");
          if (requests.length > 0) {
            for (var i4 = 0; i4 < requests.length; i4++) {
              if (requests[i4].request.handleOnlineOffline) {
                requests[i4].init();
                requests[i4].execute();
              }
            }
          }
          offline = false;
        }
      };
      atmosphere.bindEvents = function() {
        atmosphere.util.on(window, "unload", atmosphere.callbacks.unload);
        atmosphere.util.on(window, "beforeunload", atmosphere.callbacks.beforeUnload);
        atmosphere.util.on(window, "offline", atmosphere.callbacks.offline);
        atmosphere.util.on(window, "online", atmosphere.callbacks.online);
      };
      atmosphere.unbindEvents = function() {
        atmosphere.util.off(window, "unload", atmosphere.callbacks.unload);
        atmosphere.util.off(window, "beforeunload", atmosphere.callbacks.beforeUnload);
        atmosphere.util.off(window, "offline", atmosphere.callbacks.offline);
        atmosphere.util.off(window, "online", atmosphere.callbacks.online);
      };
      atmosphere.bindEvents();
      return atmosphere;
    });
  }
});

// node_modules/atmosphere.js/lib/browser.js
var require_browser = __commonJS({
  "node_modules/atmosphere.js/lib/browser.js"(exports, module) {
    module.exports = require_atmosphere();
  }
});

// node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i4 = 0; i4 < cookies.length; i4++) {
      var parts = cookies[i4].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e2) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name, attributes) {
        set(
          name,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });

// node_modules/@hilla/frontend/CookieManager.js
function e({ pathname: t2 }) {
  return t2.length > 1 && t2.endsWith("/") ? t2.slice(0, -1) : t2;
}
var i = api.withAttributes({ path: e(new URL(document.baseURI)) });
var s = i;

// node_modules/@hilla/frontend/CsrfUtils.js
var f = "X-CSRF-Token";
var i2 = "csrfToken";
var a = "XSRF-TOKEN";
function o(r) {
  if (r) {
    const e2 = r.content;
    if (e2 && e2.toLowerCase() !== "undefined")
      return e2;
  }
}
function d(r) {
  const e2 = r.head.querySelector('meta[name="_csrf_header"]');
  return o(e2);
}
function g(r) {
  const e2 = r.head.querySelector('meta[name="_csrf"]');
  return o(e2);
}
function c(r) {
  const e2 = d(r);
  let n2 = s.get(a);
  (!n2 || n2.length === 0) && (n2 = g(r));
  const t2 = {};
  return n2 && e2 && (t2._csrf = n2, t2._csrf_header = e2), t2;
}
function _(r) {
  const e2 = c(r), n2 = {};
  return e2._csrf && e2._csrf_header && (n2[e2._csrf_header] = e2._csrf), n2;
}
function m(r) {
  const e2 = {}, n2 = c(r);
  return n2._csrf && n2._csrf_header ? e2[n2._csrf_header] = n2._csrf : e2[f] = s.get(i2) ?? "", e2;
}

// node_modules/@hilla/frontend/Authentication.js
var y = "jwt.headerAndPayload";
function M(n2) {
  const e2 = new DOMParser().parseFromString(n2, "text/html");
  return c(e2);
}
function g2() {
  Array.from(document.head.querySelectorAll('meta[name="_csrf"], meta[name="_csrf_header"]')).forEach((n2) => n2.remove());
}
function u(n2) {
  g2();
  const e2 = document.createElement("meta");
  e2.name = "_csrf_header", e2.content = n2._csrf_header, document.head.appendChild(e2);
  const r = document.createElement("meta");
  r.name = "_csrf", r.content = n2._csrf, document.head.appendChild(r);
}
var T = (n2) => {
  const e2 = /window\.Vaadin = \{TypeScript: \{"csrfToken":"([0-9a-zA-Z\\-]{36})"\}\};/iu.exec(n2);
  return e2 ? e2[1] : void 0;
};
async function R(n2) {
  const e2 = await n2.text(), r = T(e2), t2 = M(e2);
  return u(t2), r;
}
async function f2(n2, e2) {
  const r = await fetch(n2, { headers: e2, method: "POST" });
  if (!r.ok)
    throw new Error(`failed to logout with response ${r.status}`);
  await R(r);
}
async function O(n2, e2, r) {
  try {
    const t2 = new FormData();
    t2.append("username", n2), t2.append("password", e2);
    const a3 = (r == null ? void 0 : r.loginProcessingUrl) ?? "login", o5 = _(document);
    o5.source = "typescript";
    const s2 = await fetch(a3, { body: t2, headers: o5, method: "POST" }), p4 = s2.headers.get("Result"), m2 = s2.headers.get("Saved-url") ?? void 0, h = s2.headers.get("Default-url") ?? void 0;
    if (s2.ok && p4 === "success") {
      const w = s2.headers.get("Vaadin-CSRF") ?? void 0, d3 = s2.headers.get("Spring-CSRF-header") ?? void 0, l = s2.headers.get("Spring-CSRF-token") ?? void 0;
      if (d3 && l) {
        const i4 = {};
        i4._csrf = l, i4._csrf_header = d3, u(i4);
      }
      return { defaultUrl: h, error: false, redirectUrl: m2, token: w };
    }
    return { error: true, errorMessage: "Check that you have entered the correct username and password and try again.", errorTitle: "Incorrect username or password." };
  } catch (t2) {
    if (t2 instanceof Error)
      return { error: true, errorMessage: t2.message, errorTitle: t2.name };
    throw t2;
  }
}
async function P(n2) {
  const e2 = (n2 == null ? void 0 : n2.logoutUrl) ?? "logout";
  try {
    const r = _(document);
    await f2(e2, r);
  } catch {
    try {
      const t2 = await (await fetch("?nocache")).text(), a3 = new DOMParser().parseFromString(t2, "text/html"), o5 = _(a3);
      await f2(e2, o5);
    } catch (r) {
      throw g2(), r;
    }
  } finally {
    s.remove(y);
  }
}
var I = class {
  constructor(e2) {
    __publicField(this, "onInvalidSessionCallback");
    this.onInvalidSessionCallback = e2;
  }
  async invoke(e2, r) {
    const t2 = { ...e2 };
    t2.request = e2.request.clone();
    const a3 = await r(e2);
    if (a3.status === 401) {
      const o5 = await this.onInvalidSessionCallback();
      if (o5.token)
        return t2.request.headers.set(f, o5.token), r(t2);
    }
    return a3;
  }
};

// node_modules/@vaadin/common-frontend/ConnectionState.js
var _a;
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2["CONNECTED"] = "connected";
  ConnectionState2["LOADING"] = "loading";
  ConnectionState2["RECONNECTING"] = "reconnecting";
  ConnectionState2["CONNECTION_LOST"] = "connection-lost";
})(ConnectionState || (ConnectionState = {}));
var ConnectionStateStore = class {
  constructor(initialState) {
    this.stateChangeListeners = /* @__PURE__ */ new Set();
    this.loadingCount = 0;
    this.connectionState = initialState;
    this.serviceWorkerMessageListener = this.serviceWorkerMessageListener.bind(this);
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener("message", this.serviceWorkerMessageListener);
      navigator.serviceWorker.ready.then((registration) => {
        var _a5;
        (_a5 = registration === null || registration === void 0 ? void 0 : registration.active) === null || _a5 === void 0 ? void 0 : _a5.postMessage({
          method: "Vaadin.ServiceWorker.isConnectionLost",
          id: "Vaadin.ServiceWorker.isConnectionLost"
        });
      });
    }
  }
  addStateChangeListener(listener) {
    this.stateChangeListeners.add(listener);
  }
  removeStateChangeListener(listener) {
    this.stateChangeListeners.delete(listener);
  }
  loadingStarted() {
    this.state = ConnectionState.LOADING;
    this.loadingCount += 1;
  }
  loadingFinished() {
    this.decreaseLoadingCount(ConnectionState.CONNECTED);
  }
  loadingFailed() {
    this.decreaseLoadingCount(ConnectionState.CONNECTION_LOST);
  }
  decreaseLoadingCount(finalState) {
    if (this.loadingCount > 0) {
      this.loadingCount -= 1;
      if (this.loadingCount === 0) {
        this.state = finalState;
      }
    }
  }
  get state() {
    return this.connectionState;
  }
  set state(newState) {
    if (newState !== this.connectionState) {
      const prevState = this.connectionState;
      this.connectionState = newState;
      this.loadingCount = 0;
      for (const listener of this.stateChangeListeners) {
        listener(prevState, this.connectionState);
      }
    }
  }
  get online() {
    return this.connectionState === ConnectionState.CONNECTED || this.connectionState === ConnectionState.LOADING;
  }
  get offline() {
    return !this.online;
  }
  serviceWorkerMessageListener(event) {
    if (typeof event.data === "object" && event.data.id === "Vaadin.ServiceWorker.isConnectionLost") {
      if (event.data.result === true) {
        this.state = ConnectionState.CONNECTION_LOST;
      }
      navigator.serviceWorker.removeEventListener("message", this.serviceWorkerMessageListener);
    }
  }
};
var isLocalhost = (hostname) => {
  if (hostname === "localhost") {
    return true;
  }
  if (hostname === "[::1]") {
    return true;
  }
  if (hostname.match(/^127\.\d+\.\d+\.\d+$/)) {
    return true;
  }
  return false;
};
var $wnd = window;
if (!((_a = $wnd.Vaadin) === null || _a === void 0 ? void 0 : _a.connectionState)) {
  let online;
  if (isLocalhost(window.location.hostname)) {
    online = true;
  } else {
    online = navigator.onLine;
  }
  $wnd.Vaadin = $wnd.Vaadin || {};
  $wnd.Vaadin.connectionState = new ConnectionStateStore(online ? ConnectionState.CONNECTED : ConnectionState.CONNECTION_LOST);
}

// node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d3 = decorators[i4])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@vaadin/common-frontend/ConnectionIndicator.js
var DEFAULT_STYLE_ID = "css-loading-indicator";
var LoadingBarState;
(function(LoadingBarState2) {
  LoadingBarState2["IDLE"] = "";
  LoadingBarState2["FIRST"] = "first";
  LoadingBarState2["SECOND"] = "second";
  LoadingBarState2["THIRD"] = "third";
})(LoadingBarState || (LoadingBarState = {}));
var ConnectionIndicator = class _ConnectionIndicator extends LitElement {
  constructor() {
    super();
    this.firstDelay = 450;
    this.secondDelay = 1500;
    this.thirdDelay = 5e3;
    this.expandedDuration = 2e3;
    this.onlineText = "Online";
    this.offlineText = "Connection lost";
    this.reconnectingText = "Connection lost, trying to reconnect...";
    this.offline = false;
    this.reconnecting = false;
    this.expanded = false;
    this.loading = false;
    this.loadingBarState = LoadingBarState.IDLE;
    this.applyDefaultThemeState = true;
    this.firstTimeout = 0;
    this.secondTimeout = 0;
    this.thirdTimeout = 0;
    this.expandedTimeout = 0;
    this.lastMessageState = ConnectionState.CONNECTED;
    this.connectionStateListener = () => {
      this.expanded = this.updateConnectionState();
      this.expandedTimeout = this.timeoutFor(this.expandedTimeout, this.expanded, () => {
        this.expanded = false;
      }, this.expandedDuration);
    };
  }
  /**
   * Initialize global connection indicator instance at
   * window.Vaadin.connectionIndicator and add instance to the document body.
   */
  static create() {
    var _a5, _b;
    const $wnd3 = window;
    if (!((_a5 = $wnd3.Vaadin) === null || _a5 === void 0 ? void 0 : _a5.connectionIndicator)) {
      $wnd3.Vaadin = $wnd3.Vaadin || {};
      $wnd3.Vaadin.connectionIndicator = document.createElement("vaadin-connection-indicator");
      document.body.appendChild($wnd3.Vaadin.connectionIndicator);
    }
    return (_b = $wnd3.Vaadin) === null || _b === void 0 ? void 0 : _b.connectionIndicator;
  }
  render() {
    return html`
      <div class="v-loading-indicator ${this.loadingBarState}" style=${this.getLoadingBarStyle()}></div>

      <div
        class="v-status-message ${classMap({
      active: this.reconnecting
    })}"
      >
        <span class="text"> ${this.renderMessage()} </span>
      </div>
    `;
  }
  connectedCallback() {
    var _a5;
    super.connectedCallback();
    const $wnd3 = window;
    if ((_a5 = $wnd3.Vaadin) === null || _a5 === void 0 ? void 0 : _a5.connectionState) {
      this.connectionStateStore = $wnd3.Vaadin.connectionState;
      this.connectionStateStore.addStateChangeListener(this.connectionStateListener);
      this.updateConnectionState();
    }
    this.updateTheme();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.connectionStateStore) {
      this.connectionStateStore.removeStateChangeListener(this.connectionStateListener);
    }
    this.updateTheme();
  }
  get applyDefaultTheme() {
    return this.applyDefaultThemeState;
  }
  set applyDefaultTheme(applyDefaultTheme) {
    if (applyDefaultTheme !== this.applyDefaultThemeState) {
      this.applyDefaultThemeState = applyDefaultTheme;
      this.updateTheme();
    }
  }
  createRenderRoot() {
    return this;
  }
  /**
   * Update state flags.
   *
   * @return true if the connection message changes, and therefore a new
   * message should be shown
   */
  updateConnectionState() {
    var _a5;
    const state = (_a5 = this.connectionStateStore) === null || _a5 === void 0 ? void 0 : _a5.state;
    this.offline = state === ConnectionState.CONNECTION_LOST;
    this.reconnecting = state === ConnectionState.RECONNECTING;
    this.updateLoading(state === ConnectionState.LOADING);
    if (this.loading) {
      return false;
    }
    if (state !== this.lastMessageState) {
      this.lastMessageState = state;
      return true;
    }
    return false;
  }
  updateLoading(loading) {
    this.loading = loading;
    this.loadingBarState = LoadingBarState.IDLE;
    this.firstTimeout = this.timeoutFor(this.firstTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.FIRST;
    }, this.firstDelay);
    this.secondTimeout = this.timeoutFor(this.secondTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.SECOND;
    }, this.secondDelay);
    this.thirdTimeout = this.timeoutFor(this.thirdTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.THIRD;
    }, this.thirdDelay);
  }
  renderMessage() {
    if (this.reconnecting) {
      return this.reconnectingText;
    }
    if (this.offline) {
      return this.offlineText;
    }
    return this.onlineText;
  }
  updateTheme() {
    if (this.applyDefaultThemeState && this.isConnected) {
      if (!document.getElementById(DEFAULT_STYLE_ID)) {
        const style = document.createElement("style");
        style.id = DEFAULT_STYLE_ID;
        style.textContent = this.getDefaultStyle();
        document.head.appendChild(style);
      }
    } else {
      const style = document.getElementById(DEFAULT_STYLE_ID);
      if (style) {
        document.head.removeChild(style);
      }
    }
  }
  getDefaultStyle() {
    return `
      @keyframes v-progress-start {
        0% {
          width: 0%;
        }
        100% {
          width: 50%;
        }
      }
      @keyframes v-progress-delay {
        0% {
          width: 50%;
        }
        100% {
          width: 90%;
        }
      }
      @keyframes v-progress-wait {
        0% {
          width: 90%;
          height: 4px;
        }
        3% {
          width: 91%;
          height: 7px;
        }
        100% {
          width: 96%;
          height: 7px;
        }
      }
      @keyframes v-progress-wait-pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.1;
        }
        100% {
          opacity: 1;
        }
      }
      .v-loading-indicator,
      .v-status-message {
        position: fixed;
        z-index: 251;
        left: 0;
        right: auto;
        top: 0;
        background-color: var(--lumo-primary-color, var(--material-primary-color, blue));
        transition: none;
      }
      .v-loading-indicator {
        width: 50%;
        height: 4px;
        opacity: 1;
        pointer-events: none;
        animation: v-progress-start 1000ms 200ms both;
      }
      .v-loading-indicator[style*='none'] {
        display: block !important;
        width: 100%;
        opacity: 0;
        animation: none;
        transition: opacity 500ms 300ms, width 300ms;
      }
      .v-loading-indicator.second {
        width: 90%;
        animation: v-progress-delay 3.8s forwards;
      }
      .v-loading-indicator.third {
        width: 96%;
        animation: v-progress-wait 5s forwards, v-progress-wait-pulse 1s 4s infinite backwards;
      }

      vaadin-connection-indicator[offline] .v-loading-indicator,
      vaadin-connection-indicator[reconnecting] .v-loading-indicator {
        display: none;
      }

      .v-status-message {
        opacity: 0;
        width: 100%;
        max-height: var(--status-height-collapsed, 8px);
        overflow: hidden;
        background-color: var(--status-bg-color-online, var(--lumo-primary-color, var(--material-primary-color, blue)));
        color: var(
          --status-text-color-online,
          var(--lumo-primary-contrast-color, var(--material-primary-contrast-color, #fff))
        );
        font-size: 0.75rem;
        font-weight: 600;
        line-height: 1;
        transition: all 0.5s;
        padding: 0 0.5em;
      }

      vaadin-connection-indicator[offline] .v-status-message,
      vaadin-connection-indicator[reconnecting] .v-status-message {
        opacity: 1;
        background-color: var(--status-bg-color-offline, var(--lumo-shade, #333));
        color: var(
          --status-text-color-offline,
          var(--lumo-primary-contrast-color, var(--material-primary-contrast-color, #fff))
        );
        background-image: repeating-linear-gradient(
          45deg,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 10px,
          rgba(255, 255, 255, 0.1) 10px,
          rgba(255, 255, 255, 0.1) 20px
        );
      }

      vaadin-connection-indicator[reconnecting] .v-status-message {
        animation: show-reconnecting-status 2s;
      }

      vaadin-connection-indicator[offline] .v-status-message:hover,
      vaadin-connection-indicator[reconnecting] .v-status-message:hover,
      vaadin-connection-indicator[expanded] .v-status-message {
        max-height: var(--status-height, 1.75rem);
      }

      vaadin-connection-indicator[expanded] .v-status-message {
        opacity: 1;
      }

      .v-status-message span {
        display: flex;
        align-items: center;
        justify-content: center;
        height: var(--status-height, 1.75rem);
      }

      vaadin-connection-indicator[reconnecting] .v-status-message span::before {
        content: '';
        width: 1em;
        height: 1em;
        border-top: 2px solid
          var(--status-spinner-color, var(--lumo-primary-color, var(--material-primary-color, blue)));
        border-left: 2px solid
          var(--status-spinner-color, var(--lumo-primary-color, var(--material-primary-color, blue)));
        border-right: 2px solid transparent;
        border-bottom: 2px solid transparent;
        border-radius: 50%;
        box-sizing: border-box;
        animation: v-spin 0.4s linear infinite;
        margin: 0 0.5em;
      }

      @keyframes v-spin {
        100% {
          transform: rotate(360deg);
        }
      }
    `;
  }
  getLoadingBarStyle() {
    switch (this.loadingBarState) {
      case LoadingBarState.IDLE:
        return "display: none";
      case LoadingBarState.FIRST:
      case LoadingBarState.SECOND:
      case LoadingBarState.THIRD:
        return "display: block";
      default:
        return "";
    }
  }
  timeoutFor(timeoutId, enabled, handler, delay) {
    if (timeoutId !== 0) {
      window.clearTimeout(timeoutId);
    }
    return enabled ? window.setTimeout(handler, delay) : 0;
  }
  static get instance() {
    return _ConnectionIndicator.create();
  }
};
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "firstDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "secondDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "thirdDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "expandedDuration", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "onlineText", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "offlineText", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "reconnectingText", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "offline", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "reconnecting", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "expanded", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "loading", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "loadingBarState", void 0);
__decorate([
  property({ type: Boolean })
], ConnectionIndicator.prototype, "applyDefaultTheme", null);
if (customElements.get("vaadin-connection-indicator") === void 0) {
  customElements.define("vaadin-connection-indicator", ConnectionIndicator);
}
var connectionIndicator = ConnectionIndicator.instance;

// node_modules/@vaadin/common-frontend/index.js
var $wnd2 = window;
$wnd2.Vaadin = $wnd2.Vaadin || {};
$wnd2.Vaadin.registrations = $wnd2.Vaadin.registrations || [];
$wnd2.Vaadin.registrations.push({
  is: "@vaadin/common-frontend",
  version: (
    /* updated-by-script */
    "0.0.18"
  )
});

// node_modules/@hilla/frontend/EndpointErrors.js
var n = class extends Error {
  constructor(s2, r, e2) {
    super(s2);
    __publicField(this, "detail");
    __publicField(this, "type");
    this.type = r, this.detail = e2;
  }
};
var i3 = class extends n {
  constructor(s2, r, e2) {
    super(s2, e2, r);
    __publicField(this, "validationErrorData");
    __publicField(this, "validationErrorMessage");
    this.validationErrorMessage = s2, this.detail = null, this.validationErrorData = r;
  }
};
var o2 = class extends n {
  constructor(s2, r) {
    super(s2, "EndpointResponseError", r);
    __publicField(this, "response");
    this.response = r;
  }
  get status() {
    return this.response.status;
  }
};
var a2 = class extends o2 {
  constructor(s2, r) {
    super(s2, r), this.type = "UnauthorizedResponseError";
  }
};
var p = class extends o2 {
  constructor(s2, r) {
    super(s2, r), this.type = "ForbiddenResponseError";
  }
};
var d2 = class {
  constructor(s2, r) {
    __publicField(this, "message");
    __publicField(this, "parameterName");
    this.message = s2, this.parameterName = r;
  }
};

// node_modules/@hilla/frontend/FluxConnection.js
var import_atmosphere = __toESM(require_browser(), 1);

// node_modules/@hilla/frontend/FluxMessages.js
function t(e2) {
  return e2 != null && typeof e2 == "object" && "@type" in e2;
}

// node_modules/@hilla/frontend/FluxConnection.js
var u2 = ((n2) => (n2.ACTIVE = "active", n2.INACTIVE = "inactive", n2))(u2 || {});
var _e, _a2, _t, _n, _s, _i, _c, _l, l_fn, _h, h_fn, _o, o_fn, _r, r_fn, _p, p_fn;
var E = class extends EventTarget {
  constructor(e2) {
    super();
    __privateAdd(this, _l);
    __privateAdd(this, _h);
    __privateAdd(this, _o);
    __privateAdd(this, _r);
    __privateAdd(this, _p);
    __publicField(this, "state", "inactive");
    __privateAdd(this, _e, /* @__PURE__ */ new Map());
    __privateAdd(this, _a2, 0);
    __privateAdd(this, _t, /* @__PURE__ */ new Map());
    __privateAdd(this, _n, /* @__PURE__ */ new Map());
    __privateAdd(this, _s, /* @__PURE__ */ new Map());
    __privateAdd(this, _i, []);
    __privateAdd(this, _c, void 0);
    __privateMethod(this, _l, l_fn).call(this, e2.replace("/connect", "").replace(/^connect/u, ""));
  }
  subscribe(e2, n2, s2) {
    const t2 = __privateGet(this, _a2).toString();
    __privateSet(this, _a2, __privateGet(this, _a2) + 1);
    const r = s2 ?? [], a3 = { "@type": "subscribe", endpointName: e2, id: t2, methodName: n2, params: r }, c2 = `${e2}.${n2}(${JSON.stringify(r)})`;
    __privateMethod(this, _r, r_fn).call(this, a3), __privateGet(this, _e).set(t2, c2);
    const o5 = { cancel: () => {
      if (!__privateGet(this, _e).has(t2))
        return;
      const i4 = { "@type": "unsubscribe", id: t2 };
      __privateMethod(this, _r, r_fn).call(this, i4), __privateMethod(this, _o, o_fn).call(this, t2);
    }, context(i4) {
      return i4.addController({ hostDisconnected() {
        o5.cancel();
      } }), o5;
    }, onComplete: (i4) => (__privateGet(this, _t).set(t2, i4), o5), onError: (i4) => (__privateGet(this, _n).set(t2, i4), o5), onNext: (i4) => (__privateGet(this, _s).set(t2, i4), o5) };
    return o5;
  }
};
_e = new WeakMap();
_a2 = new WeakMap();
_t = new WeakMap();
_n = new WeakMap();
_s = new WeakMap();
_i = new WeakMap();
_c = new WeakMap();
_l = new WeakSet();
l_fn = function(e2) {
  var _a5, _b;
  const n2 = m(document);
  __privateSet(this, _c, (_b = (_a5 = import_atmosphere.default).subscribe) == null ? void 0 : _b.call(_a5, { contentType: "application/json; charset=UTF-8", enableProtocol: true, fallbackTransport: "long-polling", headers: n2, maxReconnectOnClose: 1e7, onClose: (s2) => {
    this.state === "active" && (this.state = "inactive", this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } })));
  }, onError: (s2) => {
    console.error("error in push communication", s2);
  }, onMessage: (s2) => {
    s2.responseBody && __privateMethod(this, _h, h_fn).call(this, JSON.parse(s2.responseBody));
  }, onOpen: (s2) => {
    this.state === "inactive" && (this.state = "active", this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } })), __privateMethod(this, _p, p_fn).call(this));
  }, onReopen: (s2) => {
    this.state === "inactive" && (this.state = "active", this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } })), __privateMethod(this, _p, p_fn).call(this));
  }, reconnectInterval: 5e3, timeout: -1, trackMessageLength: true, transport: "websocket", url: e2 ? `${e2}/HILLA/push` : "HILLA/push" }));
};
_h = new WeakSet();
h_fn = function(e2) {
  var _a5;
  if (t(e2)) {
    const { id: n2 } = e2, s2 = __privateGet(this, _e).get(n2) ?? "unknown";
    if (e2["@type"] === "update") {
      const t2 = __privateGet(this, _s).get(n2);
      t2 && t2(e2.item);
    } else if (e2["@type"] === "complete")
      (_a5 = __privateGet(this, _t).get(n2)) == null ? void 0 : _a5(), __privateMethod(this, _o, o_fn).call(this, n2);
    else {
      const t2 = __privateGet(this, _n).get(n2);
      if (t2 && t2(), __privateMethod(this, _o, o_fn).call(this, n2), !t2)
        throw new Error(`Error in ${s2}: ${e2.message}`);
    }
  } else
    throw new Error(`Unknown message from server: ${String(e2)}`);
};
_o = new WeakSet();
o_fn = function(e2) {
  __privateGet(this, _s).delete(e2), __privateGet(this, _t).delete(e2), __privateGet(this, _n).delete(e2), __privateGet(this, _e).delete(e2);
};
_r = new WeakSet();
r_fn = function(e2) {
  var _a5, _b;
  this.state === "inactive" ? __privateGet(this, _i).push(e2) : (_b = (_a5 = __privateGet(this, _c)) == null ? void 0 : _a5.push) == null ? void 0 : _b.call(_a5, JSON.stringify(e2));
};
_p = new WeakSet();
p_fn = function() {
  __privateGet(this, _i).forEach((e2) => __privateMethod(this, _r, r_fn).call(this, e2)), __privateSet(this, _i, []);
};

// node_modules/@hilla/frontend/Connect.js
var o3 = window;
var _a3;
o3.Vaadin ?? (o3.Vaadin = {}), (_a3 = o3.Vaadin).registrations ?? (_a3.registrations = []), o3.Vaadin.registrations.push({ is: "endpoint" });
var V = async (r) => {
  if (!r.ok) {
    const t2 = await r.text();
    let n2;
    try {
      n2 = JSON.parse(t2);
    } catch {
      n2 = null;
    }
    const i4 = (n2 == null ? void 0 : n2.message) ?? t2.length > 0 ? t2 : `expected "200 OK" response, but got ${r.status} ${r.statusText}`, s2 = n2 == null ? void 0 : n2.type;
    if (n2 == null ? void 0 : n2.validationErrorData)
      throw new i3(i4, n2.validationErrorData, s2);
    if (s2)
      throw new n(i4, s2, n2 == null ? void 0 : n2.detail);
    switch (r.status) {
      case 401:
        throw new a2(i4, r);
      case 403:
        throw new p(i4, r);
      default:
        throw new o2(i4, r);
    }
  }
};
function p3() {
  var _a5, _b, _c2;
  return ((_c2 = (_b = (_a5 = o3.Vaadin) == null ? void 0 : _a5.Flow) == null ? void 0 : _b.clients) == null ? void 0 : _c2.TypeScript) !== void 0;
}
var _e2;
var D = class {
  constructor(t2 = {}) {
    __publicField(this, "middlewares", []);
    __publicField(this, "prefix", "/connect");
    __privateAdd(this, _e2, void 0);
    t2.prefix && (this.prefix = t2.prefix), t2.middlewares && (this.middlewares = t2.middlewares), ConnectionIndicator.create(), addEventListener("online", () => {
      var _a5;
      !p3() && ((_a5 = o3.Vaadin) == null ? void 0 : _a5.connectionState) && (o3.Vaadin.connectionState.state = ConnectionState.CONNECTED);
    }), addEventListener("offline", () => {
      var _a5;
      !p3() && ((_a5 = o3.Vaadin) == null ? void 0 : _a5.connectionState) && (o3.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST);
    });
  }
  get fluxConnection() {
    return __privateGet(this, _e2) || __privateSet(this, _e2, new E(this.prefix)), __privateGet(this, _e2);
  }
  async call(t2, n2, i4, s2) {
    if (arguments.length < 2)
      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);
    const w = { Accept: "application/json", "Content-Type": "application/json", ...m(document) }, f3 = new Request(`${this.prefix}/${t2}/${n2}`, { body: i4 !== void 0 ? JSON.stringify(i4, (a3, e2) => e2 === void 0 ? null : e2) : void 0, headers: w, method: "POST" }), x = { endpoint: t2, method: n2, params: i4, request: f3 };
    async function g3(a3, e2) {
      const d3 = await e2(a3);
      await V(d3);
      const m2 = await d3.text();
      return JSON.parse(m2, (O2, c2) => c2 === null ? void 0 : c2);
    }
    async function C(a3) {
      var _a5, _b, _c2, _d, _e3, _f, _g, _h2;
      (_b = (_a5 = o3.Vaadin) == null ? void 0 : _a5.connectionState) == null ? void 0 : _b.loadingStarted();
      try {
        const e2 = await fetch(a3.request, { signal: s2 == null ? void 0 : s2.signal });
        return (_d = (_c2 = o3.Vaadin) == null ? void 0 : _c2.connectionState) == null ? void 0 : _d.loadingFinished(), e2;
      } catch (e2) {
        return e2 instanceof Error && e2.name === "AbortError" ? (_f = (_e3 = o3.Vaadin) == null ? void 0 : _e3.connectionState) == null ? void 0 : _f.loadingFinished() : (_h2 = (_g = o3.Vaadin) == null ? void 0 : _g.connectionState) == null ? void 0 : _h2.loadingFailed(), Promise.reject(e2);
      }
    }
    return [g3, ...this.middlewares].reduceRight((a3, e2) => async (d3) => typeof e2 == "function" ? e2(d3, a3) : e2.invoke(d3, a3), C)(x);
  }
  subscribe(t2, n2, i4) {
    return this.fluxConnection.subscribe(t2, n2, i4 ? Object.values(i4) : []);
  }
};
_e2 = new WeakMap();

// node_modules/@hilla/frontend/index.js
var o4 = window;
var _a4;
o4.Vaadin ?? (o4.Vaadin = {}), (_a4 = o4.Vaadin).registrations ?? (_a4.registrations = []), o4.Vaadin.registrations.push({ is: "@hilla/frontend", version: "2.3.2" });
export {
  D as ConnectClient,
  n as EndpointError,
  o2 as EndpointResponseError,
  i3 as EndpointValidationError,
  E as FluxConnection,
  p as ForbiddenResponseError,
  I as InvalidSessionMiddleware,
  u2 as State,
  a2 as UnauthorizedResponseError,
  d2 as ValidationErrorData,
  O as login,
  P as logout
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=@hilla_frontend.js.map
