{
  "version": 3,
  "sources": ["src/GeneratorIO.ts"],
  "sourcesContent": ["import { constants } from 'node:fs';\nimport { access, mkdir, readFile, rm, writeFile } from 'node:fs/promises';\nimport { createRequire } from 'node:module';\nimport { dirname, isAbsolute, join, resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport type File from '@hilla/generator-typescript-core/File.js';\nimport Plugin, { type PluginConstructor } from '@hilla/generator-typescript-core/Plugin.js';\nimport type LoggerFactory from '@hilla/generator-typescript-utils/LoggerFactory.js';\nimport GeneratorIOException from './GeneratorIOException.js';\n\nconst require = createRequire(import.meta.url);\n\ntype PluginConstructorModule = Readonly<{\n  default: PluginConstructor;\n}>;\n\nexport default class GeneratorIO {\n  static readonly INDEX_FILENAME = 'generated-file-list.txt';\n  declare ['constructor']: typeof GeneratorIO;\n  readonly cwd: string;\n  readonly #logger: LoggerFactory;\n  readonly #outputDir: string;\n\n  constructor(outputDir: string, logger: LoggerFactory) {\n    this.cwd = process.cwd();\n    this.#outputDir = isAbsolute(outputDir) ? outputDir : resolve(this.cwd, outputDir);\n    this.#logger = logger;\n\n    logger.global.debug(`Output directory: ${this.#outputDir}`);\n  }\n\n  /**\n   * Gets the list of files generated the last time. The info is found in {@link INDEX_FILENAME}.\n   * @returns a list of files that have been generated by us\n   */\n  async getGeneratedFiles(): Promise<Set<string>> {\n    const files = new Set<string>();\n    try {\n      const indexFileContents = await this.read(this.resolveGeneratedFile(this.constructor.INDEX_FILENAME));\n      indexFileContents\n        .split('\\n')\n        .filter((n) => n.length)\n        .forEach((fileName) => files.add(fileName));\n    } catch (e) {\n      // non-existing file is OK, all other errors must be rethrown\n      if (!(e instanceof Error && 'code' in e && e.code === 'ENOENT')) {\n        throw e;\n      }\n    }\n    return files;\n  }\n\n  /**\n   * Cleans the output directory by keeping the generated files and deleting the rest of the given files.\n   *\n   * @returns a set containing deleted filenames\n   */\n  async cleanOutputDir(generatedFiles: string[], filesToDelete: Set<string>): Promise<Set<string>> {\n    this.#logger.global.debug(`Cleaning ${this.#outputDir}`);\n    await mkdir(this.#outputDir, { recursive: true });\n\n    generatedFiles.forEach((filename) => {\n      this.#logger.global.debug(`File ${filename} was re-written, should not delete it`);\n      filesToDelete.delete(filename);\n    });\n\n    const deletedFiles = new Set(\n      await Promise.all(\n        [...filesToDelete].map(async (filename) => {\n          const resolved = this.resolveGeneratedFile(filename);\n          if (await this.exists(resolved)) {\n            this.#logger.global.debug(`Deleting file ${filename}.`);\n            await rm(resolved);\n          }\n          return filename;\n        }),\n      ),\n    );\n\n    return deletedFiles;\n  }\n\n  async createFileIndex(filenames: string[]): Promise<void> {\n    await this.write(this.constructor.INDEX_FILENAME, filenames.join('\\n'));\n  }\n\n  async writeGeneratedFiles(files: readonly File[]): Promise<string[]> {\n    await this.createFileIndex(files.map((file) => file.name));\n    this.#logger.global.debug(`created index`);\n\n    return Promise.all(\n      files.map(async (file) => {\n        const newFileContent = await file.text();\n        let oldFileContent;\n        try {\n          oldFileContent = await this.read(this.resolveGeneratedFile(file.name));\n        } catch (_e) {}\n\n        if (newFileContent !== oldFileContent) {\n          this.#logger.global.debug(`writing file ${file.name}`);\n          await this.write(file.name, await file.text());\n        } else {\n          this.#logger.global.debug(`File ${file.name} stayed the same`);\n        }\n        return file.name;\n      }),\n    );\n  }\n\n  /**\n   * Checks that a file exists (is visible)\n   * @param path - the file path to check\n   */\n  // eslint-disable-next-line class-methods-use-this\n  async exists(path: string): Promise<boolean> {\n    try {\n      await access(path, constants.F_OK);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async loadPlugin(modulePath: string): Promise<PluginConstructor> {\n    this.#logger.global.debug(`Loading plugin: ${modulePath}`);\n    const module: PluginConstructorModule = await import(pathToFileURL(require.resolve(modulePath)).toString());\n    const ctr: PluginConstructor = module.default;\n\n    if (!Object.prototype.isPrototypeOf.call(Plugin, ctr)) {\n      throw new GeneratorIOException(`Plugin '${modulePath}' is not an instance of a Plugin class`);\n    }\n\n    return ctr;\n  }\n\n  resolveGeneratedFile(filename: string): string {\n    return resolve(this.#outputDir, filename);\n  }\n\n  async read(path: string): Promise<string> {\n    this.#logger.global.debug(`Reading file: ${path}`);\n    return readFile(path, 'utf8');\n  }\n\n  async write(filename: string, content: string): Promise<void> {\n    const filePath = join(this.#outputDir, filename);\n    this.#logger.global.debug(`Writing file ${filePath}.`);\n    const dir = dirname(filePath);\n    await mkdir(dir, { recursive: true });\n    return writeFile(filePath, content, 'utf-8');\n  }\n}\n"],
  "mappings": "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",
  "names": ["constants", "access", "mkdir", "readFile", "rm", "writeFile", "createRequire", "dirname", "isAbsolute", "join", "resolve", "pathToFileURL", "Plugin", "GeneratorIOException", "require", "GeneratorIO", "#logger", "#outputDir", "outputDir", "logger", "files", "n", "fileName", "generatedFiles", "filesToDelete", "filename", "resolved", "filenames", "file", "newFileContent", "oldFileContent", "path", "modulePath", "ctr", "content", "filePath", "dir"]
}
