{
  "version": 3,
  "sources": ["../src/dependencies/ImportManager.ts"],
  "sourcesContent": ["import ts, { type Identifier, type ImportDeclaration, type Statement } from 'typescript';\nimport createFullyUniqueIdentifier from '../createFullyUniqueIdentifier.js';\nimport type CodeConvertable from './CodeConvertable.js';\nimport StatementRecordManager, { type StatementRecord } from './StatementRecordManager.js';\nimport { createDependencyRecord, type DependencyRecord } from './utils.js';\n\nexport class NamedImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #collator: Intl.Collator;\n  readonly #map = new Map<string, Map<string, DependencyRecord>>();\n\n  constructor(collator: Intl.Collator) {\n    super(collator);\n    this.#collator = collator;\n  }\n\n  add(path: string, specifier: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const record = createDependencyRecord(uniqueId ?? createFullyUniqueIdentifier(specifier), isType);\n\n    if (this.#map.has(path)) {\n      this.#map.get(path)!.set(specifier, record);\n    } else {\n      this.#map.set(path, new Map([[specifier, record]]));\n    }\n\n    return record.id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string, specifier: string): Identifier | undefined {\n    return this.#map.get(path)?.get(specifier)?.id;\n  }\n\n  *identifiers(): IterableIterator<readonly [path: string, specifier: string, id: Identifier, isType: boolean]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const [specifier, { id, isType }] of specifiers) {\n        yield [path, specifier, id, isType];\n      }\n    }\n  }\n\n  isType(path: string, specifier: string): boolean | undefined {\n    return this.#map.get(path)?.get(specifier)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  *specifiers(): IterableIterator<readonly [path: string, specifier: string]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const specifier of specifiers.keys()) {\n        yield [path, specifier];\n      }\n    }\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, specifiers] of this.#map) {\n      const names = [...specifiers.keys()];\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      names.sort(this.#collator.compare);\n\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            false,\n            undefined,\n            ts.factory.createNamedImports(\n              names.map((name) => {\n                const { id, isType } = specifiers.get(name)!;\n                return ts.factory.createImportSpecifier(isType, ts.factory.createIdentifier(name), id);\n              }),\n            ),\n          ),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport class NamespaceImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, Identifier>();\n\n  add(path: string, name: string, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, id);\n    return id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path);\n  }\n\n  *identifiers(): IterableIterator<Identifier> {\n    for (const id of this.#map.values()) {\n      yield id;\n    }\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, id] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(id)),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport class DefaultImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, DependencyRecord>();\n\n  add(path: string, name: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, createDependencyRecord(id, isType));\n    return id;\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path)?.id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  *identifiers(): IterableIterator<readonly [id: Identifier, isType: boolean]> {\n    for (const { id, isType } of this.#map.values()) {\n      yield [id, isType];\n    }\n  }\n\n  isType(path: string): boolean | undefined {\n    return this.#map.get(path)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, { id, isType }] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(isType, id, undefined),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport default class ImportManager implements CodeConvertable<readonly Statement[]> {\n  readonly default: DefaultImportManager;\n  readonly named: NamedImportManager;\n  readonly namespace: NamespaceImportManager;\n\n  readonly #collator: Intl.Collator;\n\n  constructor(collator: Intl.Collator) {\n    this.default = new DefaultImportManager(collator);\n    this.named = new NamedImportManager(collator);\n    this.namespace = new NamespaceImportManager(collator);\n    this.#collator = collator;\n  }\n\n  toCode(): readonly Statement[] {\n    const records = [\n      ...this.default.statementRecords(),\n      ...this.named.statementRecords(),\n      ...this.namespace.statementRecords(),\n    ];\n    records.sort(StatementRecordManager.createComparator(this.#collator));\n\n    return records.map(([, statement]) => statement);\n  }\n\n  fromCode(source: ts.SourceFile): void {\n    this.default.clear();\n    this.named.clear();\n    this.namespace.clear();\n\n    const imports = source.statements.filter((statement): statement is ImportDeclaration =>\n      ts.isImportDeclaration(statement),\n    );\n\n    for (const { importClause, moduleSpecifier } of imports) {\n      if (!importClause) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const { name, namedBindings } = importClause;\n      const path = (moduleSpecifier as ts.StringLiteral).text;\n\n      if (namedBindings) {\n        if (ts.isNamespaceImport(namedBindings)) {\n          this.namespace.add(path, namedBindings.name.text, namedBindings.name);\n        } else {\n          for (const { isTypeOnly, name: specifier } of namedBindings.elements) {\n            this.named.add(path, specifier.text, isTypeOnly, specifier);\n          }\n        }\n      } else if (name) {\n        this.default.add(path, name.text, importClause.isTypeOnly, name);\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["ts", "createFullyUniqueIdentifier", "StatementRecordManager", "createDependencyRecord", "NamedImportManager", "#collator", "#map", "collator", "path", "specifier", "isType", "uniqueId", "record", "specifiers", "id", "names", "name", "NamespaceImportManager", "DefaultImportManager", "ImportManager", "records", "statement", "source", "imports", "importClause", "moduleSpecifier", "namedBindings", "isTypeOnly"]
}
