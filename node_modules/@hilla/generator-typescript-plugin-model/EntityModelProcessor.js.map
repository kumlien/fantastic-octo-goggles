{
  "version": 3,
  "sources": ["src/EntityModelProcessor.ts"],
  "sourcesContent": ["/* eslint-disable symbol-description */\nimport { dirname } from 'path/posix';\nimport {\n  convertReferenceSchemaToPath,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  isComposedSchema,\n  isEmptyObject,\n  isEnumSchema,\n  isObjectSchema,\n  isReferenceSchema,\n  type ObjectSchema,\n  type ReferenceSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport {\n  convertFullyQualifiedNameToRelativePath,\n  simplifyFullyQualifiedName,\n} from '@hilla/generator-typescript-core/utils.js';\nimport createSourceFile from '@hilla/generator-typescript-utils/createSourceFile.js';\nimport DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport PathManager from '@hilla/generator-typescript-utils/dependencies/PathManager.js';\nimport ts, {\n  type ClassDeclaration,\n  type ClassElement,\n  type Identifier,\n  type SourceFile,\n  type Statement,\n} from 'typescript';\nimport { ModelSchemaExpressionProcessor, ModelSchemaTypeProcessor } from './ModelSchemaProcessor.js';\nimport { importBuiltInFormModel, type Context, createModelBuildingCallback, createEmptyValueMaker } from './utils.js';\n\nexport type DependencyData = Readonly<{\n  id: Identifier;\n  path: string;\n}>;\n\nconst $dependencies = Symbol();\nconst $entity = Symbol();\nconst $fullyQualifiedName = Symbol();\nconst $model = Symbol();\nconst $processDeclaration = Symbol();\n\nexport abstract class EntityModelProcessor {\n  static process(name: string, component: Schema, context: Context): SourceFile {\n    context.owner.logger.debug(`Processing model for entity: ${name}`);\n\n    const schema = isComposedSchema(component) ? decomposeSchema(component)[0] : component;\n\n    return isEnumSchema(schema)\n      ? // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new EntityEnumModelProcessor(name).process() // eslint-disable-line no-use-before-define\n      : // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new EntityClassModelProcessor(name, component, context).process(); // eslint-disable-line no-use-before-define\n  }\n\n  protected readonly [$dependencies]: DependencyManager;\n  protected readonly [$entity]: DependencyData;\n  protected readonly [$fullyQualifiedName]: string;\n  protected readonly [$model]: DependencyData;\n  readonly #outputPathManager = new PathManager({ extension: 'ts' });\n\n  protected constructor(name: string, shouldImportEntityAsType: boolean) {\n    this[$fullyQualifiedName] = name;\n\n    const entityName = simplifyFullyQualifiedName(name);\n    const entityPath = convertFullyQualifiedNameToRelativePath(name);\n\n    const modelName = `${entityName}Model`;\n    const modelPath = `${entityPath}Model`;\n    this[$dependencies] = new DependencyManager(new PathManager({ extension: '.js', relativeTo: dirname(modelPath) }));\n\n    const { exports, imports, paths } = this[$dependencies];\n\n    this[$model] = {\n      id: exports.default.set(modelName),\n      path: modelPath,\n    };\n\n    this[$entity] = {\n      id: imports.default.add(paths.createRelativePath(entityPath), entityName, shouldImportEntityAsType),\n      path: entityPath,\n    };\n  }\n\n  process(): SourceFile {\n    const declaration = this[$processDeclaration]();\n\n    const { exports, imports } = this[$dependencies];\n    const importStatements = imports.toCode();\n    const exportStatement = exports.toCode();\n\n    return createSourceFile(\n      [...importStatements, declaration, ...exportStatement].filter(Boolean) as readonly Statement[],\n      this.#outputPathManager.createRelativePath(this[$model].path),\n    );\n  }\n\n  protected abstract [$processDeclaration](): ClassDeclaration | undefined;\n}\n\nexport class EntityClassModelProcessor extends EntityModelProcessor {\n  readonly #component: Schema;\n  readonly #context: Context;\n  readonly #fullyQualifiedName: string;\n  readonly #getPropertyModelSymbol: Identifier;\n  readonly #makeObjectEmptyValueCreator: Identifier;\n\n  constructor(name: string, component: Schema, context: Context) {\n    super(name, true);\n\n    this.#component = component;\n    this.#context = context;\n    this.#fullyQualifiedName = name;\n\n    this.#getPropertyModelSymbol = this[$dependencies].imports.named.add('@hilla/form', '_getPropertyModel');\n    this.#makeObjectEmptyValueCreator = this[$dependencies].imports.named.add(\n      '@hilla/form',\n      'makeObjectEmptyValueCreator',\n    );\n  }\n\n  protected [$processDeclaration](): ClassDeclaration | undefined {\n    const { logger } = this.#context.owner;\n\n    let entitySchema = this.#component;\n    let parent;\n\n    if (isComposedSchema(this.#component)) {\n      const decomposed = decomposeSchema(this.#component);\n\n      if (decomposed.length > 2) {\n        logger.debug(\n          this.#component,\n          `The schema for a class component ${\n            this.#fullyQualifiedName\n          } has more than two components. This plugin will ignore it.`,\n        );\n        return undefined;\n      }\n\n      const [parentSchema, childSchema] = decomposed;\n\n      if (!isReferenceSchema(parentSchema)) {\n        logger.debug(parentSchema, 'Only reference schema allowed for parent class');\n        return undefined;\n      }\n\n      entitySchema = childSchema;\n      parent = this.#processParentClass(parentSchema);\n    } else {\n      parent = importBuiltInFormModel('ObjectModel', this[$dependencies]);\n    }\n\n    return this.#processModelClass(entitySchema, this[$entity].id, parent);\n  }\n\n  #processClassElements({ properties }: ObjectSchema): readonly ClassElement[] {\n    if (!properties) {\n      return [];\n    }\n\n    return Object.entries(properties).map(([name, schema]) => {\n      const type = new ModelSchemaTypeProcessor(schema, this[$dependencies]).process();\n      const args = new ModelSchemaExpressionProcessor(schema, this[$dependencies]).process();\n\n      return ts.factory.createGetAccessorDeclaration(\n        undefined,\n        ts.factory.createIdentifier(name),\n        [],\n        type,\n        ts.factory.createBlock(\n          [\n            ts.factory.createReturnStatement(\n              ts.factory.createCallExpression(\n                ts.factory.createElementAccessExpression(ts.factory.createThis(), this.#getPropertyModelSymbol),\n                undefined,\n                [ts.factory.createStringLiteral(name), createModelBuildingCallback(type.typeName as Identifier, args)],\n              ),\n            ),\n          ],\n          true,\n        ),\n      );\n    });\n  }\n\n  #processModelClass(schema: Schema, entity: Identifier, parent: Identifier): ClassDeclaration | undefined {\n    const { logger } = this.#context.owner;\n\n    if (!isObjectSchema(schema)) {\n      logger.debug(schema, `Component is not an object: ${this.#fullyQualifiedName}`);\n      return undefined;\n    }\n\n    if (isEmptyObject(schema)) {\n      logger.warn(`Component has no properties: ${this.#fullyQualifiedName}`);\n    }\n\n    const typeT = ts.factory.createIdentifier('T');\n    const modelTypeParameters = ts.factory.createTypeParameterDeclaration(\n      undefined,\n      typeT,\n      ts.factory.createTypeReferenceNode(entity),\n      ts.factory.createTypeReferenceNode(entity),\n    );\n\n    return ts.factory.createClassDeclaration(\n      undefined,\n      this[$model].id,\n      [modelTypeParameters],\n      [\n        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n          ts.factory.createExpressionWithTypeArguments(parent, [ts.factory.createTypeReferenceNode(typeT)]),\n        ]),\n      ],\n      [\n        createEmptyValueMaker(this.#makeObjectEmptyValueCreator, this[$model].id),\n        ...this.#processClassElements(schema),\n      ],\n    );\n  }\n\n  #processParentClass(schema: ReferenceSchema): Identifier {\n    const { imports, paths } = this[$dependencies];\n\n    const specifier = convertReferenceSchemaToSpecifier(schema);\n    const path = convertReferenceSchemaToPath(schema);\n    const modelPath = paths.createRelativePath(`${path}Model`);\n    const modelSpecifier = `${specifier}Model`;\n\n    return imports.default.add(modelPath, modelSpecifier, false);\n  }\n}\n\nexport class EntityEnumModelProcessor extends EntityModelProcessor {\n  constructor(name: string) {\n    super(name, false);\n  }\n\n  protected [$processDeclaration](): ClassDeclaration {\n    const enumModel = importBuiltInFormModel('EnumModel', this[$dependencies]);\n    const enumPropertySymbol = this[$dependencies].imports.named.add('@hilla/form', '_enum');\n    const makeEnumEmptyValueCreator = this[$dependencies].imports.named.add('@hilla/form', 'makeEnumEmptyValueCreator');\n\n    return ts.factory.createClassDeclaration(\n      undefined,\n      this[$model].id,\n      undefined,\n      [\n        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n          ts.factory.createExpressionWithTypeArguments(enumModel, [\n            ts.factory.createTypeQueryNode(this[$entity].id, undefined),\n          ]),\n        ]),\n      ],\n      [\n        createEmptyValueMaker(makeEnumEmptyValueCreator, this[$model].id),\n        ts.factory.createPropertyDeclaration(\n          [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],\n          ts.factory.createComputedPropertyName(enumPropertySymbol),\n          undefined,\n          undefined,\n          this[$entity].id,\n        ),\n      ],\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["dirname", "convertReferenceSchemaToPath", "convertReferenceSchemaToSpecifier", "decomposeSchema", "isComposedSchema", "isEmptyObject", "isEnumSchema", "isObjectSchema", "isReferenceSchema", "convertFullyQualifiedNameToRelativePath", "simplifyFullyQualifiedName", "createSourceFile", "DependencyManager", "PathManager", "ts", "ModelSchemaExpressionProcessor", "ModelSchemaTypeProcessor", "importBuiltInFormModel", "createModelBuildingCallback", "createEmptyValueMaker", "$dependencies", "$entity", "$fullyQualifiedName", "$model", "$processDeclaration", "EntityModelProcessor", "name", "component", "context", "schema", "EntityEnumModelProcessor", "EntityClassModelProcessor", "#outputPathManager", "shouldImportEntityAsType", "entityName", "entityPath", "modelName", "modelPath", "exports", "imports", "paths", "declaration", "importStatements", "exportStatement", "#component", "#context", "#fullyQualifiedName", "#getPropertyModelSymbol", "#makeObjectEmptyValueCreator", "logger", "entitySchema", "parent", "decomposed", "parentSchema", "childSchema", "#processParentClass", "#processModelClass", "#processClassElements", "properties", "type", "args", "entity", "typeT", "modelTypeParameters", "specifier", "path", "modelSpecifier", "enumModel", "enumPropertySymbol", "makeEnumEmptyValueCreator"]
}
