{
  "version": 3,
  "sources": ["src/ModelSchemaProcessor.ts"],
  "sourcesContent": ["import {\n  type ArraySchema,\n  type BooleanSchema,\n  convertReferenceSchemaToPath,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  type IntegerSchema,\n  isArraySchema,\n  isBooleanSchema,\n  isComposedSchema,\n  isIntegerSchema,\n  isMapSchema,\n  isNullableSchema,\n  isNumberSchema,\n  isReferenceSchema,\n  isStringSchema,\n  type MapSchema,\n  type NumberSchema,\n  type ReferenceSchema,\n  type Schema,\n  type StringSchema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport type DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport ts, {\n  type Expression,\n  type Identifier,\n  type PropertyAssignment,\n  type TypeNode,\n  type TypeReferenceNode,\n} from 'typescript';\nimport { MetadataProcessor } from './MetadataProcessor.js';\nimport { createModelBuildingCallback, importBuiltInFormModel } from './utils.js';\nimport { hasValidationConstraints, ValidationConstraintProcessor } from './ValidationConstraintProcessor.js';\n\nconst $dependencies = Symbol();\nconst $processArray = Symbol();\nconst $processRecord = Symbol();\nconst $processReference = Symbol();\nconst $processString = Symbol();\nconst $processNumber = Symbol();\nconst $processBoolean = Symbol();\nconst $processUnknown = Symbol();\nconst $originalSchema = Symbol();\nconst $schema = Symbol();\n\nexport abstract class ModelSchemaPartProcessor<T> {\n  protected readonly [$dependencies]: DependencyManager;\n  protected readonly [$originalSchema]: Schema;\n  protected readonly [$schema]: Schema;\n\n  constructor(schema: Schema, dependencies: DependencyManager) {\n    this[$dependencies] = dependencies;\n    this[$originalSchema] = schema;\n    this[$schema] = isComposedSchema(schema) ? decomposeSchema(schema)[0] : schema;\n  }\n\n  process(): T {\n    const schema = this[$schema];\n\n    if (isReferenceSchema(schema)) {\n      return this[$processReference](schema);\n    }\n\n    if (isArraySchema(schema)) {\n      return this[$processArray](schema);\n    }\n\n    if (isMapSchema(schema)) {\n      return this[$processRecord](schema);\n    }\n\n    if (isStringSchema(schema)) {\n      return this[$processString](schema);\n    }\n\n    if (isNumberSchema(schema) || isIntegerSchema(schema)) {\n      return this[$processNumber](schema);\n    }\n\n    if (isBooleanSchema(schema)) {\n      return this[$processBoolean](schema);\n    }\n\n    return this[$processUnknown](schema);\n  }\n\n  protected abstract [$processArray](schema: ArraySchema): T;\n  protected abstract [$processBoolean](schema: BooleanSchema): T;\n  protected abstract [$processNumber](schema: IntegerSchema | NumberSchema): T;\n  protected abstract [$processRecord](schema: MapSchema): T;\n  protected abstract [$processReference](schema: ReferenceSchema): T;\n  protected abstract [$processString](schema: StringSchema): T;\n  protected abstract [$processUnknown](schema: Schema): T;\n}\n\nclass ModelSchemaInternalTypeProcessor extends ModelSchemaPartProcessor<TypeNode> {\n  protected override [$processArray](schema: ArraySchema): TypeNode {\n    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('ReadonlyArray'), [\n      new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process(),\n    ]);\n  }\n\n  protected override [$processBoolean](_: BooleanSchema): TypeNode {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n  }\n\n  protected override [$processNumber](_: IntegerSchema | NumberSchema): TypeNode {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n  }\n\n  protected override [$processRecord]({ additionalProperties: props }: MapSchema): TypeNode {\n    const valueType =\n      typeof props === 'boolean'\n        ? ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n        : new ModelSchemaInternalTypeProcessor(props, this[$dependencies]).process();\n\n    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('Record'), [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n      valueType,\n    ]);\n  }\n\n  protected override [$processReference](schema: ReferenceSchema): TypeNode {\n    const { imports, paths } = this[$dependencies];\n    const typeName = convertReferenceSchemaToSpecifier(schema);\n    const typePath = paths.createRelativePath(convertReferenceSchemaToPath(schema));\n    return ts.factory.createTypeReferenceNode(\n      imports.default.getIdentifier(typePath) ?? imports.default.add(typePath, typeName, true),\n    );\n  }\n\n  protected override [$processString](_: StringSchema): TypeNode {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n  }\n\n  protected override [$processUnknown](_: Schema): TypeNode {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n  }\n}\n\nclass ModelSchemaIdentifierProcessor extends ModelSchemaPartProcessor<Identifier> {\n  override [$processArray](_: ArraySchema): Identifier {\n    return importBuiltInFormModel('ArrayModel', this[$dependencies]);\n  }\n\n  override [$processBoolean](_: BooleanSchema): Identifier {\n    return importBuiltInFormModel('BooleanModel', this[$dependencies]);\n  }\n\n  override [$processNumber](_: IntegerSchema | NumberSchema): Identifier {\n    return importBuiltInFormModel('NumberModel', this[$dependencies]);\n  }\n\n  override [$processRecord](_: MapSchema): Identifier {\n    return importBuiltInFormModel('ObjectModel', this[$dependencies]);\n  }\n\n  override [$processReference](schema: ReferenceSchema): Identifier {\n    const { imports, paths } = this[$dependencies];\n\n    const name = `${convertReferenceSchemaToSpecifier(schema)}Model`;\n    const path = paths.createRelativePath(`${convertReferenceSchemaToPath(schema)}Model`);\n\n    return imports.default.getIdentifier(path) ?? imports.default.add(path, name);\n  }\n\n  override [$processString](_: StringSchema): Identifier {\n    return importBuiltInFormModel('StringModel', this[$dependencies]);\n  }\n\n  override [$processUnknown](_: Schema): Identifier {\n    return importBuiltInFormModel('ObjectModel', this[$dependencies]);\n  }\n}\n\nexport class ModelSchemaTypeProcessor extends ModelSchemaPartProcessor<TypeReferenceNode> {\n  readonly #id: ModelSchemaIdentifierProcessor;\n\n  constructor(schema: Schema, dependencies: DependencyManager) {\n    super(schema, dependencies);\n    this.#id = new ModelSchemaIdentifierProcessor(schema, dependencies);\n  }\n\n  protected override [$processArray](schema: ArraySchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processArray](schema), [\n      new ModelSchemaTypeProcessor(schema.items, this[$dependencies]).process(),\n    ]);\n  }\n\n  protected override [$processBoolean](schema: BooleanSchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processBoolean](schema));\n  }\n\n  protected override [$processNumber](schema: IntegerSchema | NumberSchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processNumber](schema));\n  }\n\n  protected override [$processRecord](schema: MapSchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processRecord](schema), [\n      new ModelSchemaInternalTypeProcessor(schema, this[$dependencies]).process(),\n    ]);\n  }\n\n  protected override [$processReference](schema: ReferenceSchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processReference](schema));\n  }\n\n  protected override [$processString](schema: StringSchema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processString](schema));\n  }\n\n  protected override [$processUnknown](schema: Schema): TypeReferenceNode {\n    return ts.factory.createTypeReferenceNode(this.#id[$processUnknown](schema), [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n    ]);\n  }\n}\n\nexport class ModelSchemaExpressionProcessor extends ModelSchemaPartProcessor<readonly Expression[]> {\n  readonly #validationConstraintProcessor: ValidationConstraintProcessor;\n  readonly #metadataProcessor: MetadataProcessor;\n\n  constructor(schema: Schema, dependencies: DependencyManager) {\n    super(schema, dependencies);\n    this.#validationConstraintProcessor = new ValidationConstraintProcessor((name) =>\n      importBuiltInFormModel(name, dependencies),\n    );\n    this.#metadataProcessor = new MetadataProcessor();\n  }\n\n  override process(): readonly ts.Expression[] {\n    const originalSchema = this[$originalSchema];\n\n    let result = super.process();\n\n    const modelOptionsProperties = [\n      this.#createValidatorsProperty(originalSchema),\n      this.#createMetadataProperty(originalSchema),\n    ].filter(Boolean) as PropertyAssignment[];\n\n    if (modelOptionsProperties.length > 0) {\n      const optionsObject = ts.factory.createObjectLiteralExpression(modelOptionsProperties);\n\n      result = [...result, optionsObject];\n    }\n\n    return [isNullableSchema(originalSchema) ? ts.factory.createTrue() : ts.factory.createFalse(), ...result];\n  }\n\n  protected override [$processArray](schema: ArraySchema): readonly Expression[] {\n    const model = new ModelSchemaIdentifierProcessor(schema.items, this[$dependencies]).process();\n\n    return [\n      createModelBuildingCallback(\n        model,\n        new ModelSchemaExpressionProcessor(schema.items, this[$dependencies]).process(),\n      ),\n    ];\n  }\n\n  protected override [$processBoolean](_: BooleanSchema): readonly Expression[] {\n    return [];\n  }\n\n  protected override [$processNumber](_: IntegerSchema | NumberSchema): readonly Expression[] {\n    return [];\n  }\n\n  protected override [$processRecord](_: MapSchema): readonly Expression[] {\n    return [];\n  }\n\n  protected override [$processReference](_: ReferenceSchema): readonly Expression[] {\n    return [];\n  }\n\n  protected override [$processString](_: StringSchema): readonly Expression[] {\n    return [];\n  }\n\n  protected override [$processUnknown](_: Schema): readonly Expression[] {\n    return [];\n  }\n\n  #createValidatorsProperty(schema: Schema): PropertyAssignment | null {\n    if (!hasValidationConstraints(schema)) {\n      return null;\n    }\n\n    const constraints = schema['x-validation-constraints'].map((constraint) =>\n      this.#validationConstraintProcessor.process(constraint),\n    );\n    return ts.factory.createPropertyAssignment('validators', ts.factory.createArrayLiteralExpression(constraints));\n  }\n\n  #createMetadataProperty(schema: Schema): PropertyAssignment | null {\n    const metadata = this.#metadataProcessor.process(schema);\n    return metadata ? ts.factory.createPropertyAssignment('meta', metadata) : null;\n  }\n}\n"],
  "mappings": "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",
  "names": ["convertReferenceSchemaToPath", "convertReferenceSchemaToSpecifier", "decomposeSchema", "isArraySchema", "isBooleanSchema", "isComposedSchema", "isIntegerSchema", "isMapSchema", "isNullableSchema", "isNumberSchema", "isReferenceSchema", "isStringSchema", "ts", "MetadataProcessor", "createModelBuildingCallback", "importBuiltInFormModel", "hasValidationConstraints", "ValidationConstraintProcessor", "$dependencies", "$processArray", "$processRecord", "$processReference", "$processString", "$processNumber", "$processBoolean", "$processUnknown", "$originalSchema", "$schema", "ModelSchemaPartProcessor", "schema", "dependencies", "ModelSchemaInternalTypeProcessor", "_", "props", "valueType", "imports", "paths", "typeName", "typePath", "ModelSchemaIdentifierProcessor", "name", "path", "ModelSchemaTypeProcessor", "#id", "ModelSchemaExpressionProcessor", "#validationConstraintProcessor", "#metadataProcessor", "originalSchema", "result", "modelOptionsProperties", "#createValidatorsProperty", "#createMetadataProperty", "optionsObject", "model", "constraints", "constraint", "metadata"]
}
