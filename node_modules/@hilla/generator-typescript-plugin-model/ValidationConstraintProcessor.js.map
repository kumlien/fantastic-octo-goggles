{
  "version": 3,
  "sources": ["src/ValidationConstraintProcessor.ts"],
  "sourcesContent": ["import {\n  isNonComposedRegularSchema,\n  type NonComposedRegularSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport { template, transform } from '@hilla/generator-typescript-utils/ast.js';\nimport ts, {\n  type Expression,\n  type Identifier,\n  type NewExpression,\n  type Statement,\n  type VariableStatement,\n} from 'typescript';\n\nexport type ValidationConstrainedSchema = NonComposedRegularSchema &\n  Readonly<{ 'x-validation-constraints': readonly ValidationConstraint[] }>;\n\nexport function hasValidationConstraints(schema: Schema): schema is ValidationConstrainedSchema {\n  return (\n    isNonComposedRegularSchema(schema) &&\n    'x-validation-constraints' in schema &&\n    (schema as ValidationConstrainedSchema)['x-validation-constraints'].length > 0\n  );\n}\n\nexport interface ValidationConstraint {\n  simpleName: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport type ValidationConstraintImporter = (name: string) => Identifier;\n\nfunction selector<T extends Expression>([statement]: readonly Statement[]): T {\n  return (statement as VariableStatement).declarationList.declarations[0].initializer as T;\n}\n\nconst variableStatementVar = 'const a';\n\nexport class ValidationConstraintProcessor {\n  readonly #importer: ValidationConstraintImporter;\n\n  constructor(importer: ValidationConstraintImporter) {\n    this.#importer = importer;\n  }\n\n  process(constraint: ValidationConstraint): NewExpression {\n    return ts.factory.createNewExpression(\n      this.#importer(constraint.simpleName),\n      undefined,\n      constraint.attributes ? [this.#processAttributes(constraint.attributes)] : [],\n    );\n  }\n\n  #processAttributes(attributes: Record<string, unknown>): Expression {\n    const names = Object.keys(attributes);\n    const tpl = JSON.stringify(names.includes('value') && names.length === 1 ? attributes.value : attributes);\n\n    return template(`${variableStatementVar}=${tpl}`, selector, [\n      transform((node) =>\n        ts.isPropertyAssignment(node) && ts.isStringLiteral(node.name)\n          ? ts.factory.createPropertyAssignment(node.name.text, node.initializer)\n          : node,\n      ),\n    ]);\n  }\n}\n"],
  "mappings": "AAAA,OACE,8BAAAA,MAGK,6CACP,OAAS,YAAAC,EAAU,aAAAC,MAAiB,2CACpC,OAAOC,MAMA,aAKA,SAASC,EAAyBC,EAAuD,CAC9F,OACEL,EAA2BK,CAAM,GACjC,6BAA8BA,GAC7BA,EAAuC,0BAA0B,EAAE,OAAS,CAEjF,CASA,SAASC,EAA+B,CAACC,CAAS,EAA4B,CAC5E,OAAQA,EAAgC,gBAAgB,aAAa,CAAC,EAAE,WAC1E,CAEA,MAAMC,EAAuB,UAEtB,MAAMC,CAA8B,CAChCC,GAET,YAAYC,EAAwC,CAClD,KAAKD,GAAYC,CACnB,CAEA,QAAQC,EAAiD,CACvD,OAAOT,EAAG,QAAQ,oBAChB,KAAKO,GAAUE,EAAW,UAAU,EACpC,OACAA,EAAW,WAAa,CAAC,KAAKC,GAAmBD,EAAW,UAAU,CAAC,EAAI,CAAC,CAC9E,CACF,CAEAC,GAAmBC,EAAiD,CAClE,MAAMC,EAAQ,OAAO,KAAKD,CAAU,EAC9BE,EAAM,KAAK,UAAUD,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAW,EAAID,EAAW,MAAQA,CAAU,EAExG,OAAOb,EAAS,GAAGO,CAAoB,IAAIQ,CAAG,GAAIV,EAAU,CAC1DJ,EAAWe,GACTd,EAAG,qBAAqBc,CAAI,GAAKd,EAAG,gBAAgBc,EAAK,IAAI,EACzDd,EAAG,QAAQ,yBAAyBc,EAAK,KAAK,KAAMA,EAAK,WAAW,EACpEA,CACN,CACF,CAAC,CACH,CACF",
  "names": ["isNonComposedRegularSchema", "template", "transform", "ts", "hasValidationConstraints", "schema", "selector", "statement", "variableStatementVar", "ValidationConstraintProcessor", "#importer", "importer", "constraint", "#processAttributes", "attributes", "names", "tpl", "node"]
}
