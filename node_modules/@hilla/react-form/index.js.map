{
  "version": 3,
  "sources": ["src/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/unbound-method */\nimport {\n  _fromString,\n  _validity,\n  type AbstractModel,\n  type BinderConfiguration,\n  type BinderNode,\n  BinderRoot,\n  CHANGED,\n  type DetachedModelConstructor,\n  type FieldStrategy,\n  getBinderNode,\n  getDefaultFieldStrategy,\n  hasFromString,\n  isFieldElement,\n  type Validator,\n  type ValueError,\n  type Value,\n} from '@hilla/form';\nimport { useEffect, useMemo, useReducer, useRef } from 'react';\nimport type { Writable } from 'type-fest';\nimport type { VaadinWindow } from './types.js';\n\ndeclare const __VERSION__: string;\n\nconst $wnd = window as VaadinWindow;\n\n$wnd.Vaadin ??= {};\n$wnd.Vaadin.registrations ??= [];\n$wnd.Vaadin.registrations.push({\n  is: '@hilla/react-form',\n  version: __VERSION__,\n});\n\nfunction useUpdate() {\n  const [_, update] = useReducer((x: number) => x + 1, 0);\n  return update;\n}\n\nexport type FieldDirectiveResult = Readonly<{\n  name: string;\n  onBlur(): void;\n  onChange(): void;\n  onInput(): void;\n  ref(element: HTMLElement | null): void;\n}>;\n\nexport type FieldDirective = (model: AbstractModel) => FieldDirectiveResult;\n\nexport type UseFormPartResult<M extends AbstractModel> = Readonly<{\n  defaultValue?: Value<M>;\n  dirty: boolean;\n  errors: readonly ValueError[];\n  invalid: boolean;\n  model: M;\n  name: string;\n  field: FieldDirective;\n  ownErrors: ReadonlyArray<ValueError<Value<M>>>;\n  required: boolean;\n  validators: ReadonlyArray<Validator<Value<M>>>;\n  value?: Value<M>;\n  visited: boolean;\n  addValidator(validator: Validator<Value<M>>): void;\n  setValidators(validators: ReadonlyArray<Validator<Value<M>>>): void;\n  setValue(value: Value<M> | undefined): void;\n  setVisited(visited: boolean): void;\n  validate(): Promise<readonly ValueError[]>;\n}>;\n\nexport type UseFormResult<M extends AbstractModel> = Omit<UseFormPartResult<M>, 'setValue' | 'value'> &\n  Readonly<{\n    value: Value<M>;\n    setDefaultValue(value: Value<M>): void;\n    setValue(value: Value<M>): void;\n    submit(): Promise<Value<M> | undefined | void>;\n    reset(): void;\n    clear(): void;\n    read(value: Value<M> | null | undefined): void;\n  }>;\n\ntype FieldState<T = unknown> = {\n  value?: T;\n  required: boolean;\n  invalid: boolean;\n  errorMessage: string;\n  strategy?: FieldStrategy<T>;\n  element?: HTMLElement;\n  updateValue(): void;\n  markVisited(): void;\n  ref(element: HTMLElement | null): void;\n};\n\nfunction convertFieldValue<T extends AbstractModel>(model: T, fieldValue: unknown) {\n  return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;\n}\n\nfunction getFormPart<M extends AbstractModel>(node: BinderNode<M>): Omit<UseFormPartResult<M>, 'field'> {\n  return {\n    addValidator: node.addValidator.bind(node),\n    defaultValue: node.defaultValue,\n    dirty: node.dirty,\n    errors: node.errors,\n    invalid: node.invalid,\n    model: node.model,\n    name: node.name,\n    ownErrors: node.ownErrors,\n    required: node.required,\n    setValidators(validators) {\n      node.validators = validators;\n    },\n    setValue(value) {\n      node.value = value;\n    },\n    setVisited(visited: boolean) {\n      node.visited = visited;\n    },\n    validate: node.validate.bind(node),\n    validators: node.validators,\n    value: node.value,\n    visited: node.visited,\n  };\n}\n\nfunction useFields<M extends AbstractModel>(node: BinderNode<M>): FieldDirective {\n  return useMemo(() => {\n    const registry = new WeakMap<AbstractModel, FieldState>();\n\n    return ((model: AbstractModel) => {\n      const n = getBinderNode(model);\n\n      let fieldState = registry.get(model);\n\n      if (!fieldState) {\n        fieldState = {\n          element: undefined,\n          errorMessage: '',\n          invalid: false,\n          markVisited() {\n            n.visited = true;\n          },\n          ref(element: HTMLElement | null) {\n            if (!element) {\n              fieldState!.element?.removeEventListener('change', fieldState!.updateValue);\n              fieldState!.element?.removeEventListener('input', fieldState!.updateValue);\n              fieldState!.element?.removeEventListener('blur', fieldState!.markVisited);\n              fieldState!.strategy?.removeEventListeners();\n              fieldState!.element = undefined;\n              fieldState!.strategy = undefined;\n              return;\n            }\n\n            if (!isFieldElement(element)) {\n              throw new TypeError(`Element '${element.localName}' is not a form element`);\n            }\n\n            if (fieldState!.element !== element) {\n              fieldState!.element = element;\n              fieldState!.element.addEventListener('change', fieldState!.updateValue);\n              fieldState!.element.addEventListener('input', fieldState!.updateValue);\n              fieldState!.element.addEventListener('blur', fieldState!.markVisited);\n              fieldState!.strategy = getDefaultFieldStrategy(element, model);\n            }\n          },\n          required: false,\n          strategy: undefined,\n          updateValue() {\n            if (fieldState!.strategy) {\n              // Remove invalid flag, so that .checkValidity() in Vaadin Components\n              // does not interfere with errors from Hilla.\n              fieldState!.strategy.invalid = false;\n              // When bad input is detected, skip reading new value in binder state\n              fieldState!.strategy.checkValidity();\n              if (!fieldState!.strategy.validity.badInput) {\n                fieldState!.value = fieldState!.strategy.value;\n              }\n              n[_validity] = fieldState!.strategy.validity;\n              n.value = convertFieldValue(model, fieldState!.value);\n            }\n          },\n          value: undefined,\n        };\n\n        registry.set(model, fieldState);\n      }\n\n      if (fieldState.strategy) {\n        const valueFromField = convertFieldValue(model, fieldState.value);\n        if (valueFromField !== n.value && !(Number.isNaN(n.value) && Number.isNaN(valueFromField))) {\n          fieldState.value = n.value;\n          fieldState.strategy.value = n.value;\n        }\n\n        if (fieldState.required !== n.required) {\n          fieldState.required = n.required;\n          fieldState.strategy.required = n.required;\n        }\n\n        const firstError = n.ownErrors.at(0);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const errorMessage = firstError?.message ?? '';\n        if (fieldState.errorMessage !== errorMessage) {\n          fieldState.errorMessage = errorMessage;\n          fieldState.strategy.errorMessage = errorMessage;\n        }\n\n        // Make sure invalid state is always in sync\n        fieldState.invalid = n.invalid;\n        fieldState.strategy.invalid = n.invalid;\n      }\n\n      return {\n        name: n.name,\n        ref: fieldState.ref,\n      };\n    }) as FieldDirective;\n  }, [node]);\n}\n\nexport function useForm<M extends AbstractModel>(\n  Model: DetachedModelConstructor<M>,\n  config?: BinderConfiguration<Value<M>>,\n): UseFormResult<M> {\n  const configRef = useRef<Writable<BinderConfiguration<Value<M>>>>({});\n  configRef.current.onSubmit = config?.onSubmit;\n  configRef.current.onChange = config?.onChange;\n  const update = useUpdate();\n  const binder = useMemo(() => new BinderRoot(Model, configRef.current), [Model]);\n  const field = useFields(binder);\n\n  useEffect(() => {\n    binder.addEventListener(CHANGED.type, update);\n  }, [binder]);\n\n  return {\n    ...getFormPart(binder),\n    clear: binder.clear.bind(binder),\n    field,\n    read: binder.read.bind(binder),\n    reset: binder.reset.bind(binder),\n    setDefaultValue(defaultValue) {\n      binder.defaultValue = defaultValue;\n    },\n    setValue(value) {\n      binder.value = value;\n    },\n    submit: binder.submit.bind(binder),\n    value: binder.value,\n  };\n}\n\nexport function useFormPart<M extends AbstractModel>(model: M): UseFormPartResult<M> {\n  const binderNode = getBinderNode(model);\n  const field = useFields(binderNode);\n  return {\n    ...getFormPart(binderNode),\n    field,\n  };\n}\n"],
  "mappings": "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",
  "names": ["_fromString", "_validity", "BinderRoot", "CHANGED", "getBinderNode", "getDefaultFieldStrategy", "hasFromString", "isFieldElement", "useEffect", "useMemo", "useReducer", "useRef", "$wnd", "useUpdate", "_", "update", "x", "convertFieldValue", "model", "fieldValue", "getFormPart", "node", "validators", "value", "visited", "useFields", "registry", "n", "fieldState", "element", "valueFromField", "errorMessage", "useForm", "Model", "config", "configRef", "binder", "field", "defaultValue", "useFormPart", "binderNode"]
}
