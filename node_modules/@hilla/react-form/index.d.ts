import { type AbstractModel, type BinderConfiguration, type DetachedModelConstructor, type Validator, type ValueError, type Value } from '@hilla/form';
export type FieldDirectiveResult = Readonly<{
    name: string;
    onBlur(): void;
    onChange(): void;
    onInput(): void;
    ref(element: HTMLElement | null): void;
}>;
export type FieldDirective = (model: AbstractModel) => FieldDirectiveResult;
export type UseFormPartResult<M extends AbstractModel> = Readonly<{
    defaultValue?: Value<M>;
    dirty: boolean;
    errors: readonly ValueError[];
    invalid: boolean;
    model: M;
    name: string;
    field: FieldDirective;
    ownErrors: ReadonlyArray<ValueError<Value<M>>>;
    required: boolean;
    validators: ReadonlyArray<Validator<Value<M>>>;
    value?: Value<M>;
    visited: boolean;
    addValidator(validator: Validator<Value<M>>): void;
    setValidators(validators: ReadonlyArray<Validator<Value<M>>>): void;
    setValue(value: Value<M> | undefined): void;
    setVisited(visited: boolean): void;
    validate(): Promise<readonly ValueError[]>;
}>;
export type UseFormResult<M extends AbstractModel> = Omit<UseFormPartResult<M>, 'setValue' | 'value'> & Readonly<{
    value: Value<M>;
    setDefaultValue(value: Value<M>): void;
    setValue(value: Value<M>): void;
    submit(): Promise<Value<M> | undefined | void>;
    reset(): void;
    clear(): void;
    read(value: Value<M> | null | undefined): void;
}>;
export declare function useForm<M extends AbstractModel>(Model: DetachedModelConstructor<M>, config?: BinderConfiguration<Value<M>>): UseFormResult<M>;
export declare function useFormPart<M extends AbstractModel>(model: M): UseFormPartResult<M>;
//# sourceMappingURL=index.d.ts.map