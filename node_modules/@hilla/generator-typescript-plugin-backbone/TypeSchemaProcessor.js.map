{
  "version": 3,
  "sources": ["src/TypeSchemaProcessor.ts"],
  "sourcesContent": ["import {\n  type ArraySchema,\n  convertReferenceSchemaToPath,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  isArraySchema,\n  isBooleanSchema,\n  isComposedSchema,\n  isIntegerSchema,\n  isMapSchema,\n  isNullableSchema,\n  isNumberSchema,\n  isReferenceSchema,\n  isStringSchema,\n  type MapSchema,\n  type NonComposedSchema,\n  type ReferenceSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport type DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport ts, { type TypeNode } from 'typescript';\n\nfunction createBoolean(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n}\n\nfunction createNumber(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n}\n\nfunction createString(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n}\n\nfunction createUndefined(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n}\n\nfunction createUnknown(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n}\n\nfunction unwrapPossiblyNullableSchema(schema: Schema): NonComposedSchema {\n  if (isComposedSchema(schema)) {\n    const [result] = decomposeSchema(schema);\n\n    return result as NonComposedSchema;\n  }\n\n  return schema as NonComposedSchema;\n}\n\nexport default class TypeSchemaProcessor {\n  declare ['constructor']: typeof TypeSchemaProcessor;\n  readonly #dependencies: DependencyManager;\n  readonly #schema: Schema;\n\n  constructor(schema: Schema, dependencies: DependencyManager) {\n    this.#schema = schema;\n    this.#dependencies = dependencies;\n  }\n\n  process(): readonly TypeNode[] {\n    let node: TypeNode;\n\n    const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);\n\n    if (isReferenceSchema(unwrappedSchema)) {\n      node = this.#processReference(unwrappedSchema);\n    } else if (isArraySchema(unwrappedSchema)) {\n      node = this.#processArray(unwrappedSchema);\n    } else if (isMapSchema(unwrappedSchema)) {\n      node = this.#processMap(unwrappedSchema);\n    } else if (isBooleanSchema(unwrappedSchema)) {\n      node = createBoolean();\n    } else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {\n      node = createNumber();\n    } else if (isStringSchema(unwrappedSchema)) {\n      node = createString();\n    } else {\n      node = createUnknown();\n    }\n\n    return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];\n  }\n\n  #processArray(schema: ArraySchema): TypeNode {\n    const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies).process();\n\n    return ts.factory.createTypeReferenceNode('Array', [ts.factory.createUnionTypeNode(nodes)]);\n  }\n\n  #processMap({ additionalProperties: valuesType }: MapSchema): TypeNode {\n    let valuesTypeNode: TypeNode;\n\n    if (typeof valuesType !== 'boolean') {\n      const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies).process();\n      valuesTypeNode = ts.factory.createUnionTypeNode(nodes);\n    } else {\n      valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    }\n\n    return ts.factory.createTypeReferenceNode('Record', [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n      valuesTypeNode,\n    ]);\n  }\n\n  #processReference(schema: ReferenceSchema): TypeNode {\n    const { imports, paths } = this.#dependencies;\n\n    const specifier = convertReferenceSchemaToSpecifier(schema);\n    const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));\n\n    const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);\n\n    return ts.factory.createTypeReferenceNode(identifier);\n  }\n}\n"],
  "mappings": "AAAA,OAEE,gCAAAA,EACA,qCAAAC,EACA,mBAAAC,EACA,iBAAAC,EACA,mBAAAC,EACA,oBAAAC,EACA,mBAAAC,EACA,eAAAC,EACA,oBAAAC,EACA,kBAAAC,EACA,qBAAAC,EACA,kBAAAC,MAKK,6CAEP,OAAOC,MAA2B,aAElC,SAASC,GAA0B,CACjC,OAAOD,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,cAAc,CACtE,CAEA,SAASE,GAAyB,CAChC,OAAOF,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,aAAa,CACrE,CAEA,SAASG,GAAyB,CAChC,OAAOH,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,aAAa,CACrE,CAEA,SAASI,GAA4B,CACnC,OAAOJ,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,gBAAgB,CACxE,CAEA,SAASK,GAA0B,CACjC,OAAOL,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,cAAc,CACtE,CAEA,SAASM,EAA6BC,EAAmC,CACvE,GAAId,EAAiBc,CAAM,EAAG,CAC5B,KAAM,CAACC,CAAM,EAAIlB,EAAgBiB,CAAM,EAEvC,OAAOC,CACT,CAEA,OAAOD,CACT,CAEA,MAAOE,CAAkC,CAE9BC,GACAC,GAET,YAAYJ,EAAgBK,EAAiC,CAC3D,KAAKD,GAAUJ,EACf,KAAKG,GAAgBE,CACvB,CAEA,SAA+B,CAC7B,IAAIC,EAEJ,MAAMC,EAAkBR,EAA6B,KAAKK,EAAO,EAEjE,OAAIb,EAAkBgB,CAAe,EACnCD,EAAO,KAAKE,GAAkBD,CAAe,EACpCvB,EAAcuB,CAAe,EACtCD,EAAO,KAAKG,GAAcF,CAAe,EAChCnB,EAAYmB,CAAe,EACpCD,EAAO,KAAKI,GAAYH,CAAe,EAC9BtB,EAAgBsB,CAAe,EACxCD,EAAOZ,EAAc,EACZP,EAAgBoB,CAAe,GAAKjB,EAAeiB,CAAe,EAC3ED,EAAOX,EAAa,EACXH,EAAee,CAAe,EACvCD,EAAOV,EAAa,EAEpBU,EAAOR,EAAc,EAGhBT,EAAiB,KAAKe,EAAO,EAAI,CAACE,EAAMT,EAAgB,CAAC,EAAI,CAACS,CAAI,CAC3E,CAEAG,GAAcT,EAA+B,CAC3C,MAAMW,EAAQ,IAAIT,EAAoBF,EAAO,MAAO,KAAKG,EAAa,EAAE,QAAQ,EAEhF,OAAOV,EAAG,QAAQ,wBAAwB,QAAS,CAACA,EAAG,QAAQ,oBAAoBkB,CAAK,CAAC,CAAC,CAC5F,CAEAD,GAAY,CAAE,qBAAsBE,CAAW,EAAwB,CACrE,IAAIC,EAEJ,GAAI,OAAOD,GAAe,UAAW,CACnC,MAAMD,EAAQ,IAAIT,EAAoBU,EAAY,KAAKT,EAAa,EAAE,QAAQ,EAC9EU,EAAiBpB,EAAG,QAAQ,oBAAoBkB,CAAK,CACvD,MACEE,EAAiBpB,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,cAAc,EAGhF,OAAOA,EAAG,QAAQ,wBAAwB,SAAU,CAClDA,EAAG,QAAQ,sBAAsBA,EAAG,WAAW,aAAa,EAC5DoB,CACF,CAAC,CACH,CAEAL,GAAkBR,EAAmC,CACnD,KAAM,CAAE,QAAAc,EAAS,MAAAC,CAAM,EAAI,KAAKZ,GAE1Ba,EAAYlC,EAAkCkB,CAAM,EACpDiB,EAAOF,EAAM,mBAAmBlC,EAA6BmB,CAAM,CAAC,EAEpEkB,EAAaJ,EAAQ,QAAQ,cAAcG,CAAI,GAAKH,EAAQ,QAAQ,IAAIG,EAAMD,EAAW,EAAI,EAEnG,OAAOvB,EAAG,QAAQ,wBAAwByB,CAAU,CACtD,CACF",
  "names": ["convertReferenceSchemaToPath", "convertReferenceSchemaToSpecifier", "decomposeSchema", "isArraySchema", "isBooleanSchema", "isComposedSchema", "isIntegerSchema", "isMapSchema", "isNullableSchema", "isNumberSchema", "isReferenceSchema", "isStringSchema", "ts", "createBoolean", "createNumber", "createString", "createUndefined", "createUnknown", "unwrapPossiblyNullableSchema", "schema", "result", "TypeSchemaProcessor", "#dependencies", "#schema", "dependencies", "node", "unwrappedSchema", "#processReference", "#processArray", "#processMap", "nodes", "valuesType", "valuesTypeNode", "imports", "paths", "specifier", "path", "identifier"]
}
