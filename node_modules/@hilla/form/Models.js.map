{
  "version": 3,
  "sources": ["src/Models.ts"],
  "sourcesContent": ["import isNumeric from 'validator/es/lib/isNumeric.js';\nimport { type BinderNode, getBinderNode } from './BinderNode.js';\nimport type { Validator } from './Validation.js';\nimport { IsNumber } from './Validators.js';\n\nexport const _createEmptyItemValue = Symbol('itemModel');\nexport const _parent = Symbol('parent');\nexport const _key = Symbol('key');\nexport const _fromString = Symbol('fromString');\nexport const _validators = Symbol('validators');\nexport const _meta = Symbol('meta');\nexport const _getPropertyModel = Symbol('getPropertyModel');\nexport const _enum = Symbol('enum');\n\nconst _optional = Symbol('optional');\n\nexport interface HasFromString<T> {\n  [_fromString](value: string): T;\n}\n\nexport function hasFromString<T>(model: AbstractModel<T>): model is AbstractModel<T> & HasFromString<T> {\n  return _fromString in model;\n}\n\nexport type Value<M> = M extends AbstractModel<infer T> ? T : never;\n\nexport const modelDetachedParent = { $value$: undefined };\n\nexport type ModelParent = AbstractModel | BinderNode | typeof modelDetachedParent;\n\nexport interface Annotation {\n  name: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport interface ModelMetadata {\n  javaType?: string;\n  annotations?: Annotation[];\n}\n\nexport interface ModelOptions<T> {\n  validators?: ReadonlyArray<Validator<T>>;\n  meta?: ModelMetadata;\n}\n\nexport type DetachedModelConstructor<M> = {\n  prototype: object;\n  new (parent: typeof modelDetachedParent, key: '$value$', optional: boolean): M;\n};\n\nexport function createDetachedModel<M extends AbstractModel>(type: DetachedModelConstructor<M>): M {\n  return new type(modelDetachedParent, '$value$', false);\n}\n\nexport abstract class AbstractModel<T = unknown> {\n  static createEmptyValue(): unknown {\n    return undefined;\n  }\n\n  declare readonly ['constructor']: typeof AbstractModel<T>;\n\n  readonly [_parent]?: ModelParent;\n\n  readonly [_validators]: ReadonlyArray<Validator<T>>;\n\n  readonly [_meta]: ModelMetadata;\n\n  readonly [_optional]: boolean;\n\n  [_key]: keyof any;\n\n  constructor(parent: ModelParent, key: keyof any, optional: boolean, options?: ModelOptions<T>) {\n    this[_parent] = parent;\n    this[_key] = key;\n    this[_optional] = optional;\n    this[_validators] = options?.validators ?? [];\n    this[_meta] = options?.meta ?? {};\n  }\n\n  toString(): string {\n    return String(this.valueOf());\n  }\n\n  valueOf(): T {\n    const { value } = getBinderNode(this);\n\n    if (value === undefined) {\n      throw new TypeError('Value is undefined');\n    }\n\n    return value! as T;\n  }\n}\n\nexport abstract class PrimitiveModel<T> extends AbstractModel<T> {}\n\nexport class BooleanModel extends PrimitiveModel<boolean> implements HasFromString<boolean> {\n  static override createEmptyValue = Boolean;\n\n  [_fromString](str: string): boolean {\n    // This implementation matches the values accepted by validator.js and converts all other values to false\n    // See https://github.com/validatorjs/validator.js/blob/master/src/lib/isBoolean.js\n    return ['true', '1', 'yes'].includes(str.toLowerCase());\n  }\n}\n\nexport class NumberModel extends PrimitiveModel<number> implements HasFromString<number | undefined> {\n  static override createEmptyValue = Number;\n\n  constructor(parent: ModelParent, key: keyof any, optional: boolean, options?: ModelOptions<number>) {\n    // Prepend a built-in validator to indicate NaN input\n    const validators = [new IsNumber(optional), ...(options?.validators ?? [])];\n    super(parent, key, optional, { ...options, validators });\n  }\n\n  [_fromString](str: string): number | undefined {\n    // Returning undefined is needed to support passing the validation when the value of an optional number field is\n    // an empty string\n    if (str === '') return undefined;\n    return isNumeric(str) ? Number.parseFloat(str) : NaN;\n  }\n}\n\nexport class StringModel extends PrimitiveModel<string> implements HasFromString<string> {\n  static override createEmptyValue = String;\n  [_fromString] = String;\n}\n\ndeclare enum Enum {}\n\nexport function makeEnumEmptyValueCreator<M extends EnumModel>(type: DetachedModelConstructor<M>): () => Value<M> {\n  const { [_enum]: enumObject } = createDetachedModel(type);\n  const defaultValue = Object.values(enumObject)[0] as Value<M>;\n\n  return () => defaultValue;\n}\n\nexport abstract class EnumModel<E extends typeof Enum = typeof Enum>\n  extends AbstractModel<E[keyof E]>\n  implements HasFromString<E[keyof E] | undefined>\n{\n  abstract readonly [_enum]: E;\n\n  [_fromString](value: string): E[keyof E] | undefined {\n    return value in this[_enum] ? (value as E[keyof E]) : undefined;\n  }\n}\n\nexport function* getObjectModelOwnAndParentGetters<M extends ObjectModel>(\n  model: M,\n): Generator<readonly [key: keyof Value<M>, getter: () => AbstractModel]> {\n  for (\n    let proto = Object.getPrototypeOf(model);\n    proto !== ObjectModel.prototype;\n    proto = Object.getPrototypeOf(proto)\n  ) {\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for (const [name, { get }] of Object.entries(descriptors)) {\n      if (get) {\n        yield [name as keyof Value<M>, get];\n      }\n    }\n  }\n}\n\nexport function makeObjectEmptyValueCreator<M extends ObjectModel>(type: DetachedModelConstructor<M>): () => Value<M> {\n  const model = createDetachedModel(type);\n\n  return () => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const obj: Partial<Value<M>> = {};\n\n    // Iterate the model class hierarchy up to the ObjectModel, and extract\n    // the property getter names from every prototypes\n    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {\n      const propertyModel = getter.call(model);\n      obj[key] = (\n        propertyModel[_optional] ? undefined : propertyModel.constructor.createEmptyValue()\n      ) as Value<M>[keyof Value<M>];\n    }\n\n    return obj as Value<M>;\n  };\n}\n\ntype ChildModel<T extends Record<never, never>, K extends keyof T> = AbstractModel<NonNullable<T[K]>>;\n\nexport class ObjectModel<T extends Record<never, never> = Record<never, never>> extends AbstractModel<T> {\n  static override createEmptyValue = makeObjectEmptyValueCreator(ObjectModel);\n\n  #properties: { [K in keyof T]?: ChildModel<T, K> } = {};\n\n  protected [_getPropertyModel]<K extends keyof T, M extends ChildModel<T, K>>(\n    key: K,\n    init: (parent: this, key: K) => M,\n  ): M {\n    if (!this.#properties[key]) {\n      this.#properties[key] = init(this, key);\n    }\n\n    return this.#properties[key] as M;\n  }\n}\n\nexport type ArrayItemModel<M> = M extends ArrayModel<infer MItem> ? MItem : never;\n\nexport class ArrayModel<MItem extends AbstractModel = AbstractModel> extends AbstractModel<Array<Value<MItem>>> {\n  static override createEmptyValue(): [] {\n    return [];\n  }\n\n  [_createEmptyItemValue]: () => Value<MItem>;\n\n  readonly #createItem: (parent: this, index: number) => MItem;\n  #items: Array<MItem | undefined> = [];\n\n  constructor(\n    parent: ModelParent,\n    key: keyof any,\n    optional: boolean,\n    createItem: (parent: ArrayModel<MItem>, key: number) => MItem,\n    options?: ModelOptions<Array<Value<MItem>>>,\n  ) {\n    super(parent, key, optional, options);\n    this.#createItem = createItem;\n    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue as () => Value<MItem>;\n  }\n\n  /**\n   * Iterates the current array value and yields a binder node for every item.\n   */\n  *[Symbol.iterator](): IterableIterator<BinderNode<MItem>> {\n    const array = this.valueOf();\n\n    if (array.length !== this.#items.length) {\n      this.#items.length = array.length;\n    }\n\n    for (let i = 0; i < array.length; i++) {\n      let item: MItem | undefined = this.#items[i];\n\n      if (!item) {\n        item = this.#createItem(this, i);\n        this.#items[i] = item;\n      }\n\n      yield getBinderNode(item);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["isNumeric", "getBinderNode", "IsNumber", "_createEmptyItemValue", "_parent", "_key", "_fromString", "_validators", "_meta", "_getPropertyModel", "_enum", "_optional", "hasFromString", "model", "modelDetachedParent", "createDetachedModel", "type", "AbstractModel", "parent", "key", "optional", "options", "value", "PrimitiveModel", "BooleanModel", "str", "NumberModel", "validators", "StringModel", "makeEnumEmptyValueCreator", "enumObject", "defaultValue", "EnumModel", "getObjectModelOwnAndParentGetters", "proto", "ObjectModel", "descriptors", "name", "get", "makeObjectEmptyValueCreator", "obj", "getter", "propertyModel", "#properties", "init", "ArrayModel", "#createItem", "#items", "createItem", "array", "i", "item"]
}
