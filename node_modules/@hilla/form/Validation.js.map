{
  "version": 3,
  "sources": ["src/Validation.ts"],
  "sourcesContent": ["import type { BinderNode } from './BinderNode.js';\nimport { getBinderNode } from './BinderNode.js';\nimport type { BinderRoot } from './BinderRoot.js';\nimport { type AbstractModel, NumberModel, type Value } from './Models.js';\nimport { Required } from './Validators.js';\n\nexport interface ValueError<T = unknown> {\n  property: AbstractModel | string;\n  message: string;\n  value: T;\n  validator: Validator<T>;\n}\n\nexport interface ValidationResult {\n  property: AbstractModel | string;\n  message?: string;\n}\n\nexport class ValidationError extends Error {\n  errors: readonly ValueError[];\n\n  constructor(errors: readonly ValueError[]) {\n    super(\n      [\n        'There are validation errors in the form.',\n        ...errors.map(\n          (e) => `${e.property.toString()} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`,\n        ),\n      ].join('\\n - '),\n    );\n    this.errors = errors;\n    this.name = this.constructor.name;\n  }\n}\n\nexport type InterpolateMessageCallback<M extends AbstractModel> = (\n  message: string,\n  validator: Validator<Value<M>>,\n  binderNode: BinderNode<M>,\n) => string;\n\nexport interface Validator<T = unknown> {\n  message: string;\n  impliesRequired?: boolean;\n  validate(\n    value: T,\n    binder: BinderRoot,\n  ):\n    | Promise<ValidationResult | boolean | readonly ValidationResult[]>\n    | ValidationResult\n    | boolean\n    | readonly ValidationResult[];\n}\n\nexport class ServerValidator implements Validator {\n  message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n\n  validate = (): boolean => false;\n}\n\n// The `property` field of `ValidationResult`s is a path relative to the parent.\nfunction setPropertyAbsolutePath(binderNodeName: string, result: ValidationResult): ValidationResult {\n  if (typeof result.property === 'string' && binderNodeName.length > 0) {\n    result.property = `${binderNodeName}.${result.property}`;\n  }\n  return result;\n}\n\nexport async function runValidator<M extends AbstractModel>(\n  model: M,\n  validator: Validator<Value<M>>,\n  interpolateMessageCallback?: InterpolateMessageCallback<M>,\n): Promise<ReadonlyArray<ValueError<Value<M>>>> {\n  const binderNode = getBinderNode(model);\n  const value = binderNode.value as Value<M>;\n\n  const interpolateMessage = (message: string) => {\n    if (!interpolateMessageCallback) {\n      return message;\n    }\n    return interpolateMessageCallback(message, validator, binderNode);\n  };\n\n  // If model is not required and value empty, do not run any validator. Except\n  // always validate NumberModel, which has a mandatory builtin validator\n  // to indicate NaN input.\n  if (!binderNode.required && !new Required().validate(value) && !(model instanceof NumberModel)) {\n    return [];\n  }\n\n  try {\n    const result = await validator.validate(value, binderNode.binder);\n\n    if (result === false) {\n      return [{ message: interpolateMessage(validator.message), property: binderNode.name, validator, value }];\n    }\n\n    if (result === true || (Array.isArray(result) && result.length === 0)) {\n      return [];\n    }\n\n    if (Array.isArray(result)) {\n      return result.map((result2) => ({\n        message: interpolateMessage(validator.message),\n        ...setPropertyAbsolutePath(binderNode.name, result2),\n        validator,\n        value,\n      }));\n    }\n\n    return [\n      {\n        message: interpolateMessage(validator.message),\n        ...setPropertyAbsolutePath(binderNode.name, result as ValidationResult),\n        validator,\n        value,\n      },\n    ];\n  } catch (error: unknown) {\n    console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);\n    return [{ message: 'Validator threw an error', property: binderNode.name, validator, value }];\n  }\n}\n"],
  "mappings": "AACA,OAAS,iBAAAA,MAAqB,kBAE9B,OAA6B,eAAAC,MAA+B,cAC5D,OAAS,YAAAC,MAAgB,kBAclB,MAAMC,UAAwB,KAAM,CACzC,OAEA,YAAYC,EAA+B,CACzC,MACE,CACE,2CACA,GAAGA,EAAO,IACPC,GAAM,GAAGA,EAAE,SAAS,SAAS,CAAC,MAAMA,EAAE,UAAU,YAAY,IAAI,GAAGA,EAAE,QAAU,KAAKA,EAAE,OAAO,GAAK,EAAE,EACvG,CACF,EAAE,KAAK;AAAA,IAAO,CAChB,EACA,KAAK,OAASD,EACd,KAAK,KAAO,KAAK,YAAY,IAC/B,CACF,CAqBO,MAAME,CAAqC,CAChD,QAEA,YAAYC,EAAiB,CAC3B,KAAK,QAAUA,CACjB,CAEA,SAAW,IAAe,EAC5B,CAGA,SAASC,EAAwBC,EAAwBC,EAA4C,CACnG,OAAI,OAAOA,EAAO,UAAa,UAAYD,EAAe,OAAS,IACjEC,EAAO,SAAW,GAAGD,CAAc,IAAIC,EAAO,QAAQ,IAEjDA,CACT,CAEA,eAAsBC,EACpBC,EACAC,EACAC,EAC8C,CAC9C,MAAMC,EAAaf,EAAcY,CAAK,EAChCI,EAAQD,EAAW,MAEnBE,EAAsBV,GACrBO,EAGEA,EAA2BP,EAASM,EAAWE,CAAU,EAFvDR,EAQX,GAAI,CAACQ,EAAW,UAAY,CAAC,IAAIb,EAAS,EAAE,SAASc,CAAK,GAAK,EAAEJ,aAAiBX,GAChF,MAAO,CAAC,EAGV,GAAI,CACF,MAAMS,EAAS,MAAMG,EAAU,SAASG,EAAOD,EAAW,MAAM,EAEhE,OAAIL,IAAW,GACN,CAAC,CAAE,QAASO,EAAmBJ,EAAU,OAAO,EAAG,SAAUE,EAAW,KAAM,UAAAF,EAAW,MAAAG,CAAM,CAAC,EAGrGN,IAAW,IAAS,MAAM,QAAQA,CAAM,GAAKA,EAAO,SAAW,EAC1D,CAAC,EAGN,MAAM,QAAQA,CAAM,EACfA,EAAO,IAAKQ,IAAa,CAC9B,QAASD,EAAmBJ,EAAU,OAAO,EAC7C,GAAGL,EAAwBO,EAAW,KAAMG,CAAO,EACnD,UAAAL,EACA,MAAAG,CACF,EAAE,EAGG,CACL,CACE,QAASC,EAAmBJ,EAAU,OAAO,EAC7C,GAAGL,EAAwBO,EAAW,KAAML,CAA0B,EACtE,UAAAG,EACA,MAAAG,CACF,CACF,CACF,OAASG,EAAgB,CACvB,eAAQ,MAAM,GAAGJ,EAAW,IAAI,gBAAgBF,EAAU,YAAY,IAAI,mBAAoBM,CAAK,EAC5F,CAAC,CAAE,QAAS,2BAA4B,SAAUJ,EAAW,KAAM,UAAAF,EAAW,MAAAG,CAAM,CAAC,CAC9F,CACF",
  "names": ["getBinderNode", "NumberModel", "Required", "ValidationError", "errors", "e", "ServerValidator", "message", "setPropertyAbsolutePath", "binderNodeName", "result", "runValidator", "model", "validator", "interpolateMessageCallback", "binderNode", "value", "interpolateMessage", "result2", "error"]
}
