{
  "version": 3,
  "sources": ["src/BinderRoot.ts"],
  "sourcesContent": ["import { EndpointValidationError, type ValidationErrorData } from '@hilla/frontend/EndpointErrors.js';\nimport {\n  _clearValidation,\n  _setErrorsWithDescendants,\n  _update,\n  _updateValidation,\n  BinderNode,\n  CHANGED,\n} from './BinderNode.js';\nimport { type FieldElement, type FieldStrategy, getDefaultFieldStrategy } from './Field.js';\nimport {\n  createDetachedModel,\n  _parent,\n  type AbstractModel,\n  type DetachedModelConstructor,\n  type Value,\n} from './Models.js';\nimport {\n  type InterpolateMessageCallback,\n  runValidator,\n  ServerValidator,\n  ValidationError,\n  type Validator,\n  type ValueError,\n} from './Validation.js';\n\nexport type BinderConfiguration<T> = Readonly<{\n  onChange?(oldValue?: T): void;\n  onSubmit?(value: T): Promise<T | undefined | void>;\n}>;\n\nexport type BinderRootConfiguration<T> = BinderConfiguration<T> &\n  Readonly<{\n    context?: unknown;\n  }>;\n\n/**\n * A simplified Binder that does not require a context.\n * It can be used as root when there is no Element to use as context.\n *\n * @typeParam T - Type of the value that binds to a form\n * @typeParam M - Type of the model that describes the structure of the value\n */\nexport class BinderRoot<M extends AbstractModel = AbstractModel> extends BinderNode<M> {\n  static interpolateMessageCallback?: InterpolateMessageCallback<any>;\n\n  #defaultValue!: Value<M>; // Initialized in the `read()` method\n\n  #value!: Value<M>; // Initialized in the `read()` method\n\n  readonly #emptyValue: Value<M>;\n\n  #submitting = false;\n\n  #validating = false;\n\n  #validationRequest?: Promise<void>;\n\n  #config?: BinderRootConfiguration<Value<M>>;\n\n  #validations = new Map<AbstractModel, Map<Validator, Promise<readonly ValueError[]>>>();\n\n  readonly #context: unknown = this;\n\n  /**\n   *\n   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model\n   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.\n   *\n   * ```\n   * binder = new BinderRoot(OrderModel);\n   * or\n   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});\n   * ```\n   */\n  constructor(Model: DetachedModelConstructor<M>, config?: BinderRootConfiguration<Value<M>>) {\n    super(createDetachedModel(Model));\n    // @ts-expect-error the model's parent is the binder\n    this.model[_parent] = this;\n    this.#context = config?.context ?? this;\n    this.#config = config;\n    // Initialize value instead of the parent.\n    this.initializeValue(true);\n    this.#emptyValue = this.value;\n  }\n\n  /**\n   * The initial value of the form, before any fields are edited by the user.\n   */\n  override get defaultValue(): Value<M> {\n    return this.#defaultValue;\n  }\n\n  override set defaultValue(newValue: Value<M>) {\n    this.#defaultValue = newValue;\n    this.dispatchEvent(CHANGED);\n  }\n\n  override get binder(): BinderRoot {\n    return this as BinderRoot;\n  }\n\n  /**\n   * The current value of the form.\n   */\n  override get value(): Value<M> {\n    return this.#value;\n  }\n\n  override set value(newValue: Value<M>) {\n    if (newValue === this.#value) {\n      return;\n    }\n\n    const oldValue = this.#value;\n    this.#value = newValue;\n    this[_update](oldValue);\n    this[_updateValidation]().catch(() => {});\n  }\n\n  /**\n   * Indicates the submitting status of the form.\n   * True if the form was submitted, but the submit promise is not resolved yet.\n   */\n  get submitting(): boolean {\n    return this.#submitting;\n  }\n\n  /**\n   * Indicates the validating status of the form.\n   * True when there is an ongoing validation.\n   */\n  get validating(): boolean {\n    return this.#validating;\n  }\n\n  /**\n   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.\n   *\n   * @param value - The value to read, or undefined to clear.\n   */\n  read(value: Value<M> | null | undefined): void {\n    if (value === undefined || value === null) {\n      this.clear();\n      return;\n    }\n    this.defaultValue = value;\n    if (\n      // Skip when no value is set yet (e.g., invoked from constructor)\n      this.value &&\n      // Clear validation state, then proceed if update is needed\n      this[_clearValidation]() &&\n      // When value is dirty, another update is coming from invoking the value\n      // setter below, so we skip this one to prevent duplicate updates\n      this.value === value\n    ) {\n      this[_update](this.value);\n    }\n\n    this.value = this.defaultValue;\n  }\n\n  /**\n   * Reset the form to the previous value\n   */\n  reset(): void {\n    this.read(this.#defaultValue);\n  }\n\n  /**\n   * Sets the form to empty value, as defined in the Model.\n   */\n  clear(): void {\n    this.read(this.#emptyValue);\n  }\n\n  /**\n   * Submit the current form value to a predefined\n   * onSubmit callback.\n   *\n   * It's a no-op if the onSubmit callback is undefined.\n   */\n  async submit(): Promise<Value<M> | undefined | void> {\n    const onSubmit = this.#config?.onSubmit;\n    if (onSubmit) {\n      return this.submitTo(onSubmit);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Submit the current form value to callback\n   *\n   * @param endpointMethod - the callback function\n   */\n  async submitTo<V>(endpointMethod: (value: Value<M>) => Promise<V>): Promise<V> {\n    const errors = await this.validate();\n    if (errors.length) {\n      throw new ValidationError(errors);\n    }\n\n    this.#submitting = true;\n    this[_update](this.value);\n    this.dispatchEvent(CHANGED);\n    try {\n      return await endpointMethod.call(this.#context, this.value);\n    } catch (error: unknown) {\n      if (error instanceof EndpointValidationError && error.validationErrorData.length) {\n        const valueErrors: Array<ValueError<any>> = [];\n        error.validationErrorData.forEach((data: ValidationErrorData) => {\n          const res =\n            /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(\n              data.message,\n            );\n          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? '', undefined, data.message];\n          valueErrors.push({\n            message,\n            property,\n            validator: new ServerValidator(message),\n            value,\n          });\n        });\n        this[_setErrorsWithDescendants](valueErrors);\n        throw new ValidationError(valueErrors);\n      }\n\n      throw error;\n    } finally {\n      this.#submitting = false;\n      this.defaultValue = this.value;\n      this[_update](this.value);\n    }\n  }\n\n  async requestValidation<NM extends AbstractModel>(\n    model: NM,\n    validator: Validator<Value<NM>>,\n  ): Promise<ReadonlyArray<ValueError<Value<NM>>>> {\n    let modelValidations: Map<Validator<Value<NM>>, Promise<ReadonlyArray<ValueError<Value<NM>>>>>;\n\n    if (this.#validations.has(model)) {\n      modelValidations = this.#validations.get(model) as Map<\n        Validator<Value<NM>>,\n        Promise<ReadonlyArray<ValueError<Value<NM>>>>\n      >;\n    } else {\n      modelValidations = new Map();\n      this.#validations.set(model, modelValidations);\n    }\n\n    await this.performValidation();\n\n    if (modelValidations.has(validator)) {\n      return modelValidations.get(validator)!;\n    }\n\n    const promise = runValidator(model, validator, BinderRoot.interpolateMessageCallback);\n    modelValidations.set(validator, promise);\n    const valueErrors = await promise;\n\n    modelValidations.delete(validator);\n    if (modelValidations.size === 0) {\n      this.#validations.delete(model);\n    }\n    if (this.#validations.size === 0) {\n      this.completeValidation();\n    }\n\n    return valueErrors;\n  }\n\n  /**\n   * Determines and returns the field directive strategy for the bound element.\n   * Override to customise the binding strategy for a component.\n   * The Binder extends BinderNode, see the inherited properties and methods below.\n   *\n   * @param elm - the bound element\n   * @param model - the bound model\n   */\n  getFieldStrategy<TField>(elm: HTMLElement, model?: AbstractModel<TField>): FieldStrategy {\n    return getDefaultFieldStrategy(elm as FieldElement, model);\n  }\n\n  protected performValidation(): Promise<void> | void {\n    if (!this.#validationRequest) {\n      this.#validating = true;\n      this.dispatchEvent(CHANGED);\n      this.#validationRequest = Promise.resolve().then(() => {\n        this.#validationRequest = undefined;\n      });\n    }\n    return this.#validationRequest;\n  }\n\n  protected completeValidation(): void {\n    this.#validating = false;\n    this.dispatchEvent(CHANGED);\n  }\n\n  protected override [_update](oldValue: Value<M>): void {\n    this.#config?.onChange?.call(this.#context, oldValue);\n    this.dispatchEvent(CHANGED);\n  }\n}\n"],
  "mappings": "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",
  "names": ["EndpointValidationError", "_clearValidation", "_setErrorsWithDescendants", "_update", "_updateValidation", "BinderNode", "CHANGED", "getDefaultFieldStrategy", "createDetachedModel", "_parent", "runValidator", "ServerValidator", "ValidationError", "BinderRoot", "#defaultValue", "#value", "#emptyValue", "#submitting", "#validating", "#validationRequest", "#config", "#validations", "#context", "Model", "config", "newValue", "oldValue", "value", "onSubmit", "endpointMethod", "errors", "error", "valueErrors", "data", "res", "property", "message", "model", "validator", "modelValidations", "promise", "elm"]
}
