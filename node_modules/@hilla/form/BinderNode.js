import{_createEmptyItemValue as v,_key as o,_parent as d,_validators as B,AbstractModel as w,ArrayModel as h,getObjectModelOwnAndParentGetters as k,ObjectModel as f}from"./Models.js";import{ValidityStateValidator as x}from"./Validators.js";import{_validity as l}from"./Validity.js";const c=Symbol("updateValidation"),p=Symbol("update"),y=Symbol("setErrorsWithDescendants"),E=Symbol("clearValidation"),V=new WeakMap;function u(n){let e=V.get(n);return e||(e=new M(n),V.set(n,e)),e}function b(n){return typeof n.property=="string"?n.property:u(n.property).name}function A(n,e,t,r){if(n instanceof f)return{...e,[t]:r};if(r===void 0)throw new TypeError("Unexpected undefined value");if(n instanceof h){const i=e.slice();return i[t]=r,i}throw new TypeError(`Unknown model type ${n.constructor.name}`)}const s=new Event("binder-node-changed");class g extends Error{constructor(){super("The model does not represent array")}}class I extends Error{constructor(){super("The model does not represent array item")}}const m=new WeakMap;class M extends EventTarget{model;[l];#i;#t;#o;#r=!1;constructor(e){super(),this.model=e,V.set(e,this),this.#o=new x,this.#t=e[B],this.constructor===M&&this.initializeValue()}get binder(){const e=this.parent?.binder;if(!e)throw new TypeError("BinderNode is detached");return e}get defaultValue(){const e=this.model[o],t=this.parent.defaultValue;if(this.#s()&&!(e in t)){if(m.has(this.parent))return m.get(this.parent);const r=this.model.constructor.createEmptyValue();return m.set(this.parent,r),r}return t[e]}get dirty(){return this.value!==this.defaultValue}get errors(){return[...Array.from(this.#n(),e=>e.errors).flat(),...this.ownErrors]}get invalid(){return this.errors.length>0}get name(){let{model:e}=this,t="";for(;e[d]instanceof w;)t=`${String(e[o])}${t?`.${t}`:""}`,e=e[d];return t}get ownErrors(){return this.#i?this.#i:[]}get parent(){const e=this.model[d];return e instanceof w?u(e):void 0}get required(){return this.#t.some(e=>e.impliesRequired)}get validators(){return this.#t}set validators(e){this.#t=e,this.dispatchEvent(s)}get value(){if(!this.parent)return;let{value:e}=this.parent;e===void 0&&(this.parent.initializeValue(!0),{value:e}=this.parent);const t=this.model[o];return e[t]}set value(e){this.initializeValue(),this.#e(e,void 0)}get visited(){return this.#r}set visited(e){this.#r!==e&&(this.#r=e,this[c]().catch(()=>{}),this.dispatchEvent(s))}addValidator(e){this.validators=[...this.#t,e],this.dispatchEvent(s)}appendItem(e){if(this.#a()){const t=e??this.model[v](),r=[...this.value??[],t],i=[...this.defaultValue??[],t];this.#e(r,i)}else throw new g}for(e){const t=u(e);if(t.binder!==this.binder)throw new Error("Unknown binder");return t}prependItem(e){if(this.#a()){const t=e??this.model[v](),r=[t,...this.value??[]],i=[t,...this.defaultValue??[]];this.#e(r,i)}else throw new g}removeSelf(){if(this.#s()){const e=(this.parent.value??[]).filter((r,i)=>i!==this.model[o]),t=(this.parent.defaultValue??[]).filter((r,i)=>i!==this.model[o]);this.parent.#e(e,t)}else throw new I}async validate(){const e=await Promise.all([...this.#d(),...this.#l()]).then(t=>t.flat());return this[y](e.length?e:void 0),this[p](),e}[E](){this.#r&&(this.#r=!1,this.dispatchEvent(s));let e=!1;return this.#i&&(this.#i=void 0,e=!0,this.dispatchEvent(s)),[...this.#n()].filter(t=>t[E]()).length>0&&(e=!0),e}[y](e){const{name:t}=this,r=e?e.filter(a=>b(a)===t):void 0,i=e?e.filter(a=>b(a).startsWith(t)):void 0;this.#i=r;for(const a of this.#n())a[y](i);this.dispatchEvent(s)}[p](e){this.parent&&this.parent[p]()}async[c](){this.#r?await this.validate():(this.dirty||this.invalid)&&await Promise.all([...this.#n()].map(async e=>e[c]()))}*#n(){if(this.value!==void 0){if(this.#h()&&this.defaultValue!==void 0)for(const[,e]of k(this.model)){const t=e.call(this.model);t[o]in this.defaultValue&&(yield u(t))}else if(this.#a())for(const e of this.model)yield e}}#a(){return this.model instanceof h}#s(){return this.model[d]instanceof h}#h(){return this.model instanceof f}*#d(){for(const e of this.#n())yield*e.#u(),yield*e.#d()}*#l(){yield*this.#u(),this.parent&&(yield*this.parent.#l())}*#u(){const e=this[l]&&!this[l].valid,t=!!this[l]?.badInput;if(e&&!t||!e)for(const r of this.#t)yield this.binder.requestValidation(this.model,r);e&&(yield this.binder.requestValidation(this.model,this.#o))}initializeValue(e=!1){this.parent&&(this.parent.value===void 0||this.parent.defaultValue===void 0)&&this.parent.initializeValue(!0);const t=this.model[o];let r=this.parent?this.parent.value[this.model[o]]:void 0;const i=this.parent?this.parent.defaultValue[this.model[o]]:void 0;r===void 0&&(e||!this.parent?(r=this.model.constructor.createEmptyValue(),this.#e(r,i===void 0?r:i)):this.parent.model instanceof f&&!(t in(this.parent.value||{}))&&this.#e(void 0,i===void 0?r:i))}#e(e,t){const{parent:r}=this;if(r){const i=this.model[o],a=A(r.model,r.value,i,e);if(e===t&&r.value===r.defaultValue)r.#e(a,a);else if(t!==void 0){const N=A(r.model,r.defaultValue,i,t);r.#e(a,N)}else r.#e(a,void 0)}else{const i=this;t!==void 0&&(i.defaultValue=t),i.value=e}}}export{M as BinderNode,s as CHANGED,E as _clearValidation,y as _setErrorsWithDescendants,p as _update,c as _updateValidation,u as getBinderNode};
//# sourceMappingURL=BinderNode.js.map
