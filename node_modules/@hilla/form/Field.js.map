{
  "version": 3,
  "sources": ["src/Field.ts"],
  "sourcesContent": ["/* eslint-disable accessor-pairs,sort-keys */\nimport { type ElementPart, noChange, nothing, type PropertyPart } from 'lit';\nimport { directive, Directive, type DirectiveParameters, type PartInfo, PartType } from 'lit/directive.js';\nimport { getBinderNode } from './BinderNode.js';\nimport { _fromString, type AbstractModel, ArrayModel, BooleanModel, hasFromString, ObjectModel } from './Models.js';\nimport type { ValueError } from './Validation.js';\nimport { _validity, defaultValidity } from './Validity.js';\n\nexport interface FieldBase<T> {\n  required: boolean;\n  invalid: boolean;\n  errorMessage: string;\n  value: T | undefined;\n}\n\n/**\n * Subset of the HTML constraint validation API with the `checkValidity()` method.\n */\nexport type FieldConstraintValidation = Readonly<{\n  validity: ValidityState;\n  checkValidity(): boolean;\n}>;\n\nexport type FieldElement<T = unknown> = FieldBase<T> & HTMLElement & Partial<FieldConstraintValidation>;\n\nconst props = ['required', 'invalid', 'errorMessage', 'value', 'validity', 'checkValidity'];\nexport function isFieldElement<T>(element: HTMLElement): element is FieldElement<T> {\n  return props.some((prop) => prop in element);\n}\n\ninterface FieldElementHolder<T> {\n  get element(): FieldElement<T>;\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: FieldElement<T>);\n}\n\ninterface Field<T> extends FieldBase<T> {\n  readonly model?: AbstractModel<T>;\n}\n\ninterface FieldState<T> extends Field<T>, FieldElementHolder<T> {\n  name: string;\n  validity: ValidityState;\n  strategy: FieldStrategy<T>;\n}\n\nexport type FieldStrategy<T = any> = Field<T> &\n  FieldConstraintValidation & {\n    removeEventListeners(): void;\n  };\n\nexport abstract class AbstractFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>>\n  implements FieldStrategy<T>\n{\n  abstract required: boolean;\n\n  abstract invalid: boolean;\n\n  readonly model?: AbstractModel<T>;\n\n  #element: E;\n\n  /**\n   * @privateRemarks\n   * Fallback for missing .validity property API in Vaadin components.\n   */\n  #validityFallback: ValidityState = defaultValidity;\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    this.#element = element;\n    this.model = model;\n  }\n\n  get element(): E {\n    return this.#element;\n  }\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: E) {\n    this.#element = element;\n  }\n\n  get value(): T | undefined {\n    return this.#element.value;\n  }\n\n  set value(value: T | undefined) {\n    this.#element.value = value;\n  }\n\n  set errorMessage(_: string) {}\n\n  get validity(): ValidityState {\n    return this.#element.validity ?? this.#validityFallback;\n  }\n\n  checkValidity(): boolean {\n    if (!this.#element.checkValidity) {\n      return true;\n    }\n\n    const valid = this.#element.checkValidity();\n    this.#validityFallback = {\n      ...defaultValidity,\n      valid,\n      ...(valid ? {} : this.#detectValidityError()),\n    };\n    return valid;\n  }\n\n  setAttribute(key: string, val: any): void {\n    if (val) {\n      this.#element.setAttribute(key, '');\n    } else {\n      this.#element.removeAttribute(key);\n    }\n  }\n\n  removeEventListeners(): void {}\n\n  #detectValidityError(): Readonly<Partial<ValidityState>> {\n    if (!('inputElement' in this.#element)) {\n      // Not a Vaadin component field\n      return { customError: true };\n    }\n\n    const inputElement = this.#element.inputElement as FieldElement<string>;\n\n    if (this.#element.value === '') {\n      if (inputElement.value === '') {\n        return { valueMissing: true };\n      }\n      // Some value is entered, but not meaningful to the\n      // web component \u2014 assume parse error.\n      return { badInput: true };\n    }\n    // Unknown constraint violation\n    return { customError: true };\n  }\n}\n\nexport class VaadinFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  #invalid = false;\n  readonly #boundOnValidated = this.#onValidated.bind(this);\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    super(element, model);\n    element.addEventListener('validated', this.#boundOnValidated);\n  }\n\n  set required(value: boolean) {\n    this.element.required = value;\n  }\n\n  set invalid(value: boolean) {\n    this.#invalid = value;\n    this.element.invalid = value;\n  }\n\n  override set errorMessage(value: string) {\n    this.element.errorMessage = value;\n  }\n\n  override removeEventListeners(): void {\n    this.element.removeEventListener('validated', this.#boundOnValidated);\n  }\n\n  #onValidated(e: Event): void {\n    if (!(e instanceof CustomEvent) || typeof e.detail !== 'object') {\n      return;\n    }\n\n    // Override built-in changes of the `invalid` flag in Vaadin components\n    // to keep the `invalid` property state of the web component in sync.\n    const invalid = !(e.detail satisfies Partial<ValidityState> as Partial<ValidityState>).valid;\n    if (this.#invalid !== invalid) {\n      this.element.invalid = this.#invalid;\n    }\n  }\n}\n\nexport class GenericFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  set required(value: boolean) {\n    this.setAttribute('required', value);\n  }\n\n  set invalid(value: boolean) {\n    this.setAttribute('invalid', value);\n  }\n}\n\ntype CheckedFieldElement<T> = FieldElement<T> & {\n  checked: boolean;\n};\n\nexport class CheckedFieldStrategy<\n  T = any,\n  E extends CheckedFieldElement<T> = CheckedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model instanceof BooleanModel) {\n      return this.element.checked as T;\n    }\n\n    return this.element.checked ? this.element.value : undefined;\n  }\n\n  override set value(val: T | undefined) {\n    (this.element as { checked: boolean }).checked = /^(true|on)$/iu.test(String(val));\n  }\n}\n\ntype ComboBoxFieldElement<T> = FieldElement<T> & {\n  value: string;\n  selectedItem: T | null;\n};\n\nexport class ComboBoxFieldStrategy<\n  T,\n  E extends ComboBoxFieldElement<T> = ComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {\n      const { selectedItem } = this.element;\n      return selectedItem ?? undefined;\n    }\n\n    return super.value;\n  }\n\n  override set value(val: T | undefined) {\n    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {\n      this.element.selectedItem = val ?? null;\n    } else {\n      super.value = val;\n    }\n  }\n}\n\ntype MultiSelectComboBoxFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selectedItems: T;\n};\n\nexport class MultiSelectComboBoxFieldStrategy<\n  T,\n  E extends MultiSelectComboBoxFieldElement<T> = MultiSelectComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selectedItems;\n  }\n\n  override set value(val: any) {\n    this.element.selectedItems = val;\n  }\n}\n\ntype SelectedFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selected: T;\n};\n\nexport class SelectedFieldStrategy<\n  T,\n  E extends SelectedFieldElement<T> = SelectedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selected;\n  }\n\n  override set value(val: T) {\n    this.element.selected = val;\n  }\n}\n\ntype MaybeVaadinElementConstructor = {\n  readonly version?: string;\n};\n\nexport function getDefaultFieldStrategy<T>(elm: FieldElement<T>, model?: AbstractModel<T>): AbstractFieldStrategy<T> {\n  switch (elm.localName) {\n    case 'vaadin-checkbox':\n    case 'vaadin-radio-button':\n      return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n    case 'vaadin-combo-box':\n      return new ComboBoxFieldStrategy(elm as ComboBoxFieldElement<T>, model);\n    case 'vaadin-list-box':\n      return new SelectedFieldStrategy(elm as SelectedFieldElement<T>, model);\n    case 'vaadin-multi-select-combo-box':\n      return new MultiSelectComboBoxFieldStrategy(elm as MultiSelectComboBoxFieldElement<T>, model);\n    case 'vaadin-rich-text-editor':\n      return new GenericFieldStrategy(elm, model);\n    default:\n      if (elm.localName === 'input' && /^(checkbox|radio)$/u.test((elm as unknown as HTMLInputElement).type)) {\n        return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n      }\n      return (elm.constructor as unknown as MaybeVaadinElementConstructor).version\n        ? new VaadinFieldStrategy(elm, model)\n        : new GenericFieldStrategy(elm, model);\n  }\n}\n\nfunction convertFieldValue<T extends AbstractModel>(model: T, fieldValue: unknown) {\n  return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;\n}\n\n/**\n * Binds a form field component into a model.\n *\n * Example usage:\n *\n * ```\n * <vaadin-text-field ...=\"${field(model.name)}\">\n * </vaadin-text-field>\n * ```\n */\nexport const field = directive(\n  class extends Directive {\n    fieldState?: FieldState<any>;\n\n    constructor(partInfo: PartInfo) {\n      super(partInfo);\n      if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {\n        throw new Error('Use as \"<element {field(...)}\" or <element ...={field(...)}\"');\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    override render(_model: AbstractModel<any>, _effect?: (element: Element) => void) {\n      return nothing;\n    }\n\n    override update(part: ElementPart | PropertyPart, [model, effect]: DirectiveParameters<this>) {\n      const element = part.element as FieldElement & HTMLInputElement;\n\n      const binderNode = getBinderNode(model);\n\n      if (!this.fieldState) {\n        const fieldState = {\n          errorMessage: '',\n          name: '',\n          value: '',\n          required: false,\n          invalid: false,\n          model,\n          validity: defaultValidity,\n          element,\n          strategy: binderNode.binder.getFieldStrategy(element, model),\n        };\n\n        this.fieldState = fieldState;\n\n        const updateValueFromElement = () => {\n          fieldState.strategy.checkValidity();\n          // When bad input is detected, skip reading new value in binder state\n          if (!fieldState.strategy.validity.badInput) {\n            fieldState.value = fieldState.strategy.value;\n          }\n          fieldState.validity = fieldState.strategy.validity;\n          binderNode[_validity] = fieldState.validity;\n          binderNode.value = convertFieldValue(model, fieldState.value);\n          if (effect !== undefined) {\n            effect.call(element, element);\n          }\n        };\n\n        element.addEventListener('input', updateValueFromElement);\n\n        const changeBlurHandler = () => {\n          updateValueFromElement();\n          binderNode.visited = true;\n        };\n\n        element.addEventListener('blur', changeBlurHandler);\n        element.addEventListener('change', changeBlurHandler);\n      }\n\n      const { fieldState } = this;\n\n      if (fieldState.element !== element || fieldState.model !== model) {\n        fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);\n      }\n\n      const { name } = binderNode;\n      if (name !== fieldState.name) {\n        fieldState.name = name;\n        element.setAttribute('name', name);\n      }\n\n      const { value } = binderNode;\n      const valueFromField = convertFieldValue(model, fieldState.value);\n      if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {\n        fieldState.value = value;\n        fieldState.strategy.value = value;\n      }\n\n      const { required } = binderNode;\n      if (required !== fieldState.required) {\n        fieldState.required = required;\n        fieldState.strategy.required = required;\n      }\n\n      const firstError: ValueError<any> | undefined = binderNode.ownErrors[0];\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const errorMessage = firstError?.message || '';\n      if (errorMessage !== fieldState.errorMessage) {\n        fieldState.errorMessage = errorMessage;\n        fieldState.strategy.errorMessage = errorMessage;\n      }\n\n      const { invalid } = binderNode;\n      if (invalid !== fieldState.invalid) {\n        fieldState.invalid = invalid;\n        fieldState.strategy.invalid = invalid;\n      }\n\n      return noChange;\n    }\n  },\n);\n"],
  "mappings": "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",
  "names": ["noChange", "nothing", "directive", "Directive", "PartType", "getBinderNode", "_fromString", "ArrayModel", "BooleanModel", "hasFromString", "ObjectModel", "_validity", "defaultValidity", "props", "isFieldElement", "element", "prop", "AbstractFieldStrategy", "#element", "#validityFallback", "model", "value", "_", "valid", "#detectValidityError", "key", "val", "inputElement", "VaadinFieldStrategy", "#invalid", "#boundOnValidated", "#onValidated", "invalid", "GenericFieldStrategy", "CheckedFieldStrategy", "ComboBoxFieldStrategy", "selectedItem", "MultiSelectComboBoxFieldStrategy", "SelectedFieldStrategy", "getDefaultFieldStrategy", "elm", "convertFieldValue", "fieldValue", "field", "partInfo", "_model", "_effect", "part", "effect", "binderNode", "fieldState", "updateValueFromElement", "changeBlurHandler", "name", "valueFromField", "required", "errorMessage"]
}
