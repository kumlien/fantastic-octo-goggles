{
  "version": 3,
  "sources": ["src/BinderNode.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\n/*\n * Copyright 2000-2020 Vaadin Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n// TODO: Fix dependency cycle\n\nimport type { BinderRoot } from './BinderRoot.js';\nimport {\n  _createEmptyItemValue,\n  _key,\n  _parent,\n  _validators,\n  AbstractModel,\n  type ArrayItemModel,\n  ArrayModel,\n  getObjectModelOwnAndParentGetters,\n  ObjectModel,\n  type Value,\n} from './Models.js';\nimport type { Validator, ValueError } from './Validation.js';\nimport { ValidityStateValidator } from './Validators.js';\nimport { _validity } from './Validity.js';\n\nexport const _updateValidation = Symbol('updateValidation');\nexport const _update = Symbol('update');\nexport const _setErrorsWithDescendants = Symbol('setErrorsWithDescendants');\nexport const _clearValidation = Symbol('clearValidation');\n\nconst nodes = new WeakMap<AbstractModel, BinderNode>();\n\nexport function getBinderNode<M extends AbstractModel>(model: M): BinderNode<M> {\n  let node = nodes.get(model);\n\n  if (!node) {\n    node = new BinderNode(model);\n    nodes.set(model, node);\n  }\n\n  return node as BinderNode<M>;\n}\n\nfunction getErrorPropertyName(valueError: ValueError): string {\n  return typeof valueError.property === 'string' ? valueError.property : getBinderNode(valueError.property).name;\n}\n\nfunction updateObjectOrArrayKey<M extends AbstractModel>(\n  model: M,\n  value: Value<M>,\n  key: keyof any,\n  keyValue: unknown,\n): Value<M> {\n  if (model instanceof ObjectModel) {\n    // Value contained in object - replace object in parent\n    return {\n      ...(value as Record<never, never> & Value<M>),\n      [key]: keyValue,\n    };\n  }\n\n  if (keyValue === undefined) {\n    throw new TypeError('Unexpected undefined value');\n  }\n\n  if (model instanceof ArrayModel) {\n    // Value contained in array - replace array in parent\n    const array = (value as unknown[]).slice();\n    array[key as number] = keyValue;\n    return array as Value<M>;\n  }\n\n  throw new TypeError(`Unknown model type ${(model as AbstractModel).constructor.name}`);\n}\n\nexport const CHANGED = new Event('binder-node-changed');\n\nclass NotArrayModelError extends Error {\n  constructor() {\n    super('The model does not represent array');\n  }\n}\n\nclass NotArrayItemModelError extends Error {\n  constructor() {\n    super('The model does not represent array item');\n  }\n}\n\ndeclare class ArrayItemBinderNode<M extends AbstractModel> extends BinderNode<M> {\n  // @ts-expect-error: re-defining the parent getter.\n  declare readonly parent: BinderNode<ArrayModel<M>>;\n}\n\nconst defaultArrayItemCache = new WeakMap<BinderNode, unknown>();\n\n/**\n * The BinderNode\\<M\\> class provides the form binding related APIs\n * with respect to a particular model instance.\n *\n * Structurally, model instances form a tree, in which the object\n * and array models have child nodes of field and array item model\n * instances.\n */\nexport class BinderNode<M extends AbstractModel = AbstractModel> extends EventTarget {\n  declare readonly ['constructor']: typeof BinderNode;\n  readonly model: M;\n  /**\n   * The validity state read from the bound element, if any. Represents the\n   * HTML element internal validation.\n   *\n   * For elements with `validity.valid === false`, the value in the\n   * bound element is considered as invalid.\n   */\n  [_validity]?: ValidityState;\n  #ownErrors?: ReadonlyArray<ValueError<Value<M>>>;\n  #validators: ReadonlyArray<Validator<Value<M>>>;\n  readonly #validityStateValidator: ValidityStateValidator<Value<M>>;\n  #visited = false;\n\n  constructor(model: M) {\n    super();\n    this.model = model;\n    nodes.set(model, this);\n    this.#validityStateValidator = new ValidityStateValidator<Value<M>>();\n    this.#validators = model[_validators];\n\n    // Workaround for children initialization with private props\n    if (this.constructor === BinderNode) {\n      this.initializeValue();\n    }\n  }\n\n  /**\n   * The binder for the top-level model.\n   */\n  get binder(): BinderRoot {\n    const binder = this.parent?.binder;\n\n    if (!binder) {\n      throw new TypeError('BinderNode is detached');\n    }\n\n    return binder;\n  }\n\n  /**\n   * The default value related to the model\n   */\n  get defaultValue(): Value<M> | undefined {\n    const key = this.model[_key];\n    const parentDefaultValue = this.parent!.defaultValue as { readonly [key in typeof key]?: Value<M> };\n\n    if (this.#isArrayItem() && !(key in parentDefaultValue)) {\n      if (defaultArrayItemCache.has(this.parent)) {\n        return defaultArrayItemCache.get(this.parent) as Value<M>;\n      }\n\n      const value = this.model.constructor.createEmptyValue();\n      defaultArrayItemCache.set(this.parent, value);\n      return value as Value<M>;\n    }\n\n    return parentDefaultValue[key];\n  }\n\n  /**\n   * True if the current value is different from the defaultValue.\n   */\n  get dirty(): boolean {\n    return this.value !== this.defaultValue;\n  }\n\n  /**\n   * The combined array of all errors for this node\u2019s model and all its nested\n   * models\n   */\n  get errors(): readonly ValueError[] {\n    return [...Array.from(this.#getChildBinderNodes(), (node) => node.errors).flat(), ...this.ownErrors];\n  }\n\n  /**\n   * Indicates if there is any error for the node's model.\n   */\n  get invalid(): boolean {\n    return this.errors.length > 0;\n  }\n\n  /**\n   * The name generated from the model structure, used to set the name\n   * attribute on the field components.\n   */\n  get name(): string {\n    let { model }: { model: AbstractModel } = this;\n    let name = '';\n\n    while (model[_parent] instanceof AbstractModel) {\n      name = `${String(model[_key])}${name ? `.${name}` : ''}`;\n      model = model[_parent];\n    }\n\n    return name;\n  }\n\n  /**\n   * The array of validation errors directly related with the model.\n   */\n  get ownErrors(): ReadonlyArray<ValueError<Value<M>>> {\n    return this.#ownErrors ? this.#ownErrors : [];\n  }\n\n  /**\n   * The parent node, if this binder node corresponds to a nested model,\n   * otherwise undefined for the top-level binder.\n   */\n  get parent(): BinderNode | undefined {\n    const modelParent = this.model[_parent];\n    return modelParent instanceof AbstractModel ? getBinderNode(modelParent) : undefined;\n  }\n\n  /**\n   * True if the value is required to be non-empty.\n   */\n  get required(): boolean {\n    return this.#validators.some((validator) => validator.impliesRequired);\n  }\n\n  /**\n   * The array of validators for the model. The default value is defined in the\n   * model.\n   */\n  get validators(): ReadonlyArray<Validator<Value<M>>> {\n    return this.#validators;\n  }\n\n  set validators(validators: ReadonlyArray<Validator<Value<M>>>) {\n    this.#validators = validators;\n    this.dispatchEvent(CHANGED);\n  }\n\n  /**\n   * The current value related to the model\n   */\n  get value(): Value<M> | undefined {\n    if (!this.parent) {\n      return undefined;\n    }\n\n    let { value } = this.parent;\n\n    if (value === undefined) {\n      this.parent.initializeValue(true);\n      ({ value } = this.parent);\n    }\n\n    const key = this.model[_key];\n\n    // The value of parent in unknown, so we need to cast it.\n    type ParentValue = { readonly [K in typeof key]: Value<M> };\n    return (value as ParentValue)[key];\n  }\n\n  set value(value: Value<M> | undefined) {\n    this.initializeValue();\n    this.#setValueState(value, undefined);\n  }\n\n  /**\n   * True if the bound field was ever focused and blurred by the user.\n   */\n  get visited(): boolean {\n    return this.#visited;\n  }\n\n  set visited(v: boolean) {\n    if (this.#visited !== v) {\n      this.#visited = v;\n      this[_updateValidation]().catch(() => {});\n      this.dispatchEvent(CHANGED);\n    }\n  }\n\n  /**\n   * A helper method to add a validator\n   *\n   * @param validator - a validator\n   */\n  addValidator(validator: Validator<Value<M>>): void {\n    this.validators = [...this.#validators, validator];\n    this.dispatchEvent(CHANGED);\n  }\n\n  /**\n   * Append an item to the array value.\n   *\n   * Requires the context model to be an array reference.\n   *\n   * @param item - optional new item value, an empty item is\n   * appended if the argument is omitted\n   */\n  appendItem(item?: Value<ArrayItemModel<M>>): void {\n    if (this.#isArray()) {\n      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();\n      const newValue = [...(this.value ?? []), itemValueOrEmptyValue];\n      const newDefaultValue = [...(this.defaultValue ?? []), itemValueOrEmptyValue];\n      this.#setValueState(newValue, newDefaultValue);\n    } else {\n      throw new NotArrayModelError();\n    }\n  }\n\n  /**\n   * Returns a binder node for the nested model instance.\n   *\n   * @param model - The nested model instance\n   */\n  for<N extends AbstractModel>(model: N): BinderNode<N> {\n    const binderNode = getBinderNode(model);\n    if (binderNode.binder !== this.binder) {\n      throw new Error('Unknown binder');\n    }\n\n    return binderNode;\n  }\n\n  prependItem(item?: Value<ArrayItemModel<M>>): void {\n    if (this.#isArray()) {\n      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();\n      const newValue = [itemValueOrEmptyValue, ...(this.value ?? [])];\n      const newDefaultValue = [itemValueOrEmptyValue, ...(this.defaultValue ?? [])];\n      this.#setValueState(newValue, newDefaultValue);\n    } else {\n      throw new NotArrayModelError();\n    }\n  }\n\n  removeSelf(): void {\n    if (this.#isArrayItem()) {\n      const newValue = (this.parent.value ?? []).filter((_, i) => i !== this.model[_key]);\n      const newDefaultValue = (this.parent.defaultValue ?? []).filter((_, i) => i !== this.model[_key]);\n      this.parent.#setValueState(newValue, newDefaultValue);\n    } else {\n      throw new NotArrayItemModelError();\n    }\n  }\n\n  /**\n   * Runs all validation callbacks potentially affecting this\n   * or any nested model. Returns the combined array of all\n   * errors as in the errors property.\n   */\n  async validate(): Promise<readonly ValueError[]> {\n    const errors = await Promise.all([\n      ...this.#requestValidationOfDescendants(),\n      ...this.#requestValidationWithAncestors(),\n    ]).then((arr) => arr.flat());\n    this[_setErrorsWithDescendants](errors.length ? errors : undefined);\n    this[_update]();\n    return errors;\n  }\n\n  protected [_clearValidation](): boolean {\n    if (this.#visited) {\n      this.#visited = false;\n      this.dispatchEvent(CHANGED);\n    }\n    let needsUpdate = false;\n    if (this.#ownErrors) {\n      this.#ownErrors = undefined;\n      needsUpdate = true;\n      this.dispatchEvent(CHANGED);\n    }\n    if ([...this.#getChildBinderNodes()].filter((childBinderNode) => childBinderNode[_clearValidation]()).length > 0) {\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n\n  protected [_setErrorsWithDescendants](errors?: readonly ValueError[]): void {\n    const { name } = this;\n    const ownErrors = errors\n      ? (errors.filter((valueError) => getErrorPropertyName(valueError) === name) as ReadonlyArray<\n          ValueError<Value<M>>\n        >)\n      : undefined;\n    const relatedErrors = errors\n      ? errors.filter((valueError) => getErrorPropertyName(valueError).startsWith(name))\n      : undefined;\n    this.#ownErrors = ownErrors;\n    for (const childBinderNode of this.#getChildBinderNodes()) {\n      childBinderNode[_setErrorsWithDescendants](relatedErrors);\n    }\n    this.dispatchEvent(CHANGED);\n  }\n\n  protected [_update](_?: Value<M>): void {\n    if (this.parent) {\n      this.parent[_update]();\n    }\n  }\n\n  protected async [_updateValidation](): Promise<void> {\n    if (this.#visited) {\n      await this.validate();\n    } else if (this.dirty || this.invalid) {\n      await Promise.all(\n        [...this.#getChildBinderNodes()].map(async (childBinderNode) => childBinderNode[_updateValidation]()),\n      );\n    }\n  }\n\n  *#getChildBinderNodes(): Generator<BinderNode, void, void> {\n    if (this.value === undefined) {\n      // Undefined value cannot have child properties and items.\n      return;\n    }\n\n    if (this.#isObject() && this.defaultValue !== undefined) {\n      for (const [, getter] of getObjectModelOwnAndParentGetters(this.model)) {\n        const childModel = getter.call(this.model);\n        // We need to skip all non-initialised optional fields here in order\n        // to prevent infinite recursion for circular references in the model.\n        // Here we rely on presence of keys in `defaultValue` to detect all\n        // initialised fields. The keys in `defaultValue` are defined for all\n        // non-optional fields plus those optional fields whose values were\n        // set from initial `binder.read()` or `binder.clear()` or by using a\n        // binder node (e.g., form binding) for a nested field.\n        if (childModel[_key] in (this.defaultValue as Record<never, never>)) {\n          yield getBinderNode(childModel);\n        }\n      }\n    } else if (this.#isArray()) {\n      for (const childBinderNode of this.model) {\n        yield childBinderNode;\n      }\n    }\n  }\n\n  #isArray(): this is BinderNode<ArrayModel> {\n    return this.model instanceof ArrayModel;\n  }\n\n  #isArrayItem(): this is ArrayItemBinderNode<M> {\n    return this.model[_parent] instanceof ArrayModel;\n  }\n\n  #isObject(): this is BinderNode<ObjectModel> {\n    return this.model instanceof ObjectModel;\n  }\n\n  *#requestValidationOfDescendants(): Generator<Promise<readonly ValueError[]>, void, void> {\n    for (const node of this.#getChildBinderNodes()) {\n      yield* node.#runOwnValidators();\n      yield* node.#requestValidationOfDescendants();\n    }\n  }\n\n  *#requestValidationWithAncestors(): Generator<Promise<readonly ValueError[]>, void, void> {\n    yield* this.#runOwnValidators();\n\n    if (this.parent) {\n      yield* this.parent.#requestValidationWithAncestors();\n    }\n  }\n\n  *#runOwnValidators(): Generator<Promise<readonly ValueError[]>, void, void> {\n    const hasInvalidState = this[_validity] && !this[_validity].valid;\n    const hasBadInput = !!this[_validity]?.badInput;\n\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if ((hasInvalidState && !hasBadInput) || !hasInvalidState) {\n      for (const validator of this.#validators) {\n        yield this.binder.requestValidation(this.model, validator);\n      }\n    }\n\n    if (hasInvalidState) {\n      yield this.binder.requestValidation(this.model, this.#validityStateValidator);\n    }\n  }\n\n  initializeValue(forceInitialize = false): void {\n    // First, make sure parents have value initialized\n    if (\n      this.parent &&\n      (this.parent.value === undefined || (this.parent.defaultValue as Value<M> | undefined) === undefined)\n    ) {\n      this.parent.initializeValue(true);\n    }\n\n    const key = this.model[_key];\n    let value: Value<M> | undefined = this.parent\n      ? (this.parent.value as { [key in typeof key]: Value<M> })[this.model[_key]]\n      : undefined;\n\n    const defaultValue: Value<M> | undefined = this.parent\n      ? (this.parent.defaultValue as { readonly [key in typeof key]: Value<M> })[this.model[_key]]\n      : undefined;\n\n    if (value === undefined) {\n      // Initialize value if this is the root level node, or it is enforced\n      if (forceInitialize || !this.parent) {\n        value = this.model.constructor.createEmptyValue() as Value<M>;\n        this.#setValueState(value, defaultValue === undefined ? value : defaultValue);\n      } else if (\n        this.parent.model instanceof ObjectModel &&\n        !(key in ((this.parent.value || {}) as { [key in typeof key]?: Value<M> }))\n      ) {\n        this.#setValueState(undefined, defaultValue === undefined ? value : defaultValue);\n      }\n    }\n  }\n\n  #setValueState(value: Value<M> | undefined, defaultValue: Value<M> | undefined): void {\n    const { parent } = this;\n    if (parent) {\n      const key = this.model[_key];\n      const parentValue = updateObjectOrArrayKey(parent.model, parent.value, key, value);\n      const keepPristine = value === defaultValue && parent.value === parent.defaultValue;\n      if (keepPristine) {\n        // Keep value and defaultValue equal, so that `dirty` stays false\n        parent.#setValueState(parentValue, parentValue);\n      } else if (defaultValue !== undefined) {\n        // Update value and defaultValue at the same time with different content\n        const parentDefaultValue = updateObjectOrArrayKey(parent.model, parent.defaultValue, key, defaultValue);\n        parent.#setValueState(parentValue, parentDefaultValue);\n      } else {\n        parent.#setValueState(parentValue, undefined);\n      }\n    } else {\n      // Root level model - update the binder root\n      const binder = this as unknown as BinderRoot<M>;\n      if (defaultValue !== undefined) {\n        binder.defaultValue = defaultValue;\n      }\n      binder.value = value!;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["_createEmptyItemValue", "_key", "_parent", "_validators", "AbstractModel", "ArrayModel", "getObjectModelOwnAndParentGetters", "ObjectModel", "ValidityStateValidator", "_validity", "_updateValidation", "_update", "_setErrorsWithDescendants", "_clearValidation", "nodes", "getBinderNode", "model", "node", "BinderNode", "getErrorPropertyName", "valueError", "updateObjectOrArrayKey", "value", "key", "keyValue", "array", "CHANGED", "NotArrayModelError", "NotArrayItemModelError", "defaultArrayItemCache", "#ownErrors", "#validators", "#validityStateValidator", "#visited", "binder", "parentDefaultValue", "#isArrayItem", "#getChildBinderNodes", "name", "modelParent", "validator", "validators", "#setValueState", "v", "item", "#isArray", "itemValueOrEmptyValue", "newValue", "newDefaultValue", "binderNode", "_", "errors", "#requestValidationOfDescendants", "#requestValidationWithAncestors", "arr", "needsUpdate", "childBinderNode", "ownErrors", "relatedErrors", "#isObject", "getter", "childModel", "#runOwnValidators", "hasInvalidState", "hasBadInput", "forceInitialize", "defaultValue", "parent", "parentValue"]
}
