{
  "version": 3,
  "sources": ["src/Schema.ts"],
  "sourcesContent": ["import type { OpenAPIV3 } from 'openapi-types';\nimport type { ReadonlyDeep } from 'type-fest';\nimport { convertFullyQualifiedNameToRelativePath, simplifyFullyQualifiedName, type Nullified } from './utils.js';\n\nexport type ReferenceSchema = ReadonlyDeep<OpenAPIV3.ReferenceObject>;\nexport type ArraySchema = ReadonlyDeep<OpenAPIV3.ArraySchemaObject>;\nexport type NonArraySchema = ReadonlyDeep<OpenAPIV3.NonArraySchemaObject>;\nexport type RegularSchema = ArraySchema | NonArraySchema;\n\nexport type NullableSchema = Readonly<Required<Pick<RegularSchema, 'nullable'>>> & RegularSchema;\n\nexport type AnyOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'anyOf'>>> & RegularSchema;\nexport type AllOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'allOf'>>> & RegularSchema;\nexport type OneOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'oneOf'>>> & RegularSchema;\nexport type NotRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'not'>>> & RegularSchema;\nexport type ComposedSchema =\n  | AllOfRuleComposedSchema\n  | AnyOfRuleComposedSchema\n  | NotRuleComposedSchema\n  | OneOfRuleComposedSchema;\n\nexport type NonComposedRegularSchema = Readonly<Nullified<RegularSchema, 'allOf' | 'anyOf' | 'oneOf'>> & RegularSchema;\nexport type NonComposedSchema = NonComposedRegularSchema | ReferenceSchema;\n\nexport type BooleanSchema = NonComposedRegularSchema & Readonly<{ type: 'boolean' }>;\nexport type IntegerSchema = NonComposedRegularSchema & Readonly<{ type: 'integer' }>;\nexport type NumberSchema = NonComposedRegularSchema & Readonly<{ type: 'number' }>;\nexport type ObjectSchema = NonComposedRegularSchema & Readonly<{ type: 'object' }>;\nexport type StringSchema = NonComposedRegularSchema & Readonly<{ type: 'string' }>;\n\nexport type EnumSchema = Readonly<Required<Pick<StringSchema, 'enum'>>> & StringSchema;\nexport type EmptyObjectSchema = ObjectSchema & Readonly<Nullified<ObjectSchema, 'properties'>>;\nexport type NonEmptyObjectSchema = ObjectSchema & Readonly<Required<Pick<ObjectSchema, 'properties'>>>;\nexport type MapSchema = EmptyObjectSchema & Readonly<Required<Pick<ObjectSchema, 'additionalProperties'>>>;\n\nexport type Schema = ReferenceSchema | RegularSchema;\n\nexport function isReferenceSchema(schema: Schema): schema is ReferenceSchema {\n  return '$ref' in schema;\n}\n\nexport function isAnyOfRuleComposedSchema(schema: Schema): schema is AnyOfRuleComposedSchema {\n  return 'anyOf' in schema;\n}\n\nexport function isAllOfRuleComposedSchema(schema: Schema): schema is AllOfRuleComposedSchema {\n  return 'allOf' in schema;\n}\n\nexport function isOneOfRuleComposedSchema(schema: Schema): schema is OneOfRuleComposedSchema {\n  return 'oneOf' in schema;\n}\n\nexport function isNotRuleComposedSchema(schema: Schema): schema is NotRuleComposedSchema {\n  return 'not' in schema;\n}\n\nexport function isComposedSchema(schema: Schema): schema is ComposedSchema {\n  return (\n    isAnyOfRuleComposedSchema(schema) ||\n    isAllOfRuleComposedSchema(schema) ||\n    isOneOfRuleComposedSchema(schema) ||\n    isNotRuleComposedSchema(schema)\n  );\n}\n\nexport function isNonComposedSchema(schema: Schema): schema is NonComposedSchema {\n  return !isComposedSchema(schema);\n}\n\nexport function isNonComposedRegularSchema(schema: Schema): schema is NonComposedRegularSchema {\n  return isNonComposedSchema(schema) && !isReferenceSchema(schema);\n}\n\nexport function isNullableSchema(schema: Schema): schema is NullableSchema {\n  return !isReferenceSchema(schema) && !!schema.nullable;\n}\n\nexport function decomposeSchema(schema: ComposedSchema): readonly Schema[] {\n  if (isAnyOfRuleComposedSchema(schema)) {\n    return schema.anyOf;\n  }\n\n  if (isAllOfRuleComposedSchema(schema)) {\n    return schema.allOf;\n  }\n\n  if (isOneOfRuleComposedSchema(schema)) {\n    return schema.oneOf;\n  }\n\n  return [schema.not];\n}\n\nexport function isArraySchema(schema: Schema): schema is ArraySchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'array';\n}\n\nexport function isBooleanSchema(schema: Schema): schema is BooleanSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'boolean';\n}\n\nexport function isIntegerSchema(schema: Schema): schema is IntegerSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'integer';\n}\n\nexport function isNumberSchema(schema: Schema): schema is NumberSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'number';\n}\n\nexport function isObjectSchema(schema: Schema): schema is ObjectSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'object';\n}\n\nexport function isStringSchema(schema: Schema): schema is StringSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'string';\n}\n\nexport function isEnumSchema(schema: Schema): schema is EnumSchema {\n  return isStringSchema(schema) && !!schema.enum;\n}\n\nexport function isEmptyObject(schema: Schema): schema is EmptyObjectSchema {\n  return isObjectSchema(schema) && !schema.properties;\n}\n\nexport function isMapSchema(schema: Schema): schema is MapSchema {\n  return isEmptyObject(schema) && !!schema.additionalProperties;\n}\n\nexport function convertReferenceSchemaToSpecifier({ $ref }: ReferenceSchema): string {\n  return simplifyFullyQualifiedName($ref);\n}\n\nconst COMPONENTS_SCHEMAS_REF_LENGTH = '#/components/schemas/'.length;\n\nexport function convertReferenceSchemaToPath({ $ref }: ReferenceSchema): string {\n  return convertFullyQualifiedNameToRelativePath($ref.substring(COMPONENTS_SCHEMAS_REF_LENGTH));\n}\n\nexport function resolveReference(\n  schemas: ReadonlyDeep<OpenAPIV3.ComponentsObject>['schemas'],\n  { $ref }: ReferenceSchema,\n): Schema | undefined {\n  if (schemas) {\n    for (const [name, schema] of Object.entries(schemas)) {\n      if ($ref.includes(name)) {\n        return schema;\n      }\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "AAEA,OAAS,2CAAAA,EAAyC,8BAAAC,MAAkD,aAmC7F,SAASC,EAAkBC,EAA2C,CAC3E,MAAO,SAAUA,CACnB,CAEO,SAASC,EAA0BD,EAAmD,CAC3F,MAAO,UAAWA,CACpB,CAEO,SAASE,EAA0BF,EAAmD,CAC3F,MAAO,UAAWA,CACpB,CAEO,SAASG,EAA0BH,EAAmD,CAC3F,MAAO,UAAWA,CACpB,CAEO,SAASI,EAAwBJ,EAAiD,CACvF,MAAO,QAASA,CAClB,CAEO,SAASK,EAAiBL,EAA0C,CACzE,OACEC,EAA0BD,CAAM,GAChCE,EAA0BF,CAAM,GAChCG,EAA0BH,CAAM,GAChCI,EAAwBJ,CAAM,CAElC,CAEO,SAASM,EAAoBN,EAA6C,CAC/E,MAAO,CAACK,EAAiBL,CAAM,CACjC,CAEO,SAASO,EAA2BP,EAAoD,CAC7F,OAAOM,EAAoBN,CAAM,GAAK,CAACD,EAAkBC,CAAM,CACjE,CAEO,SAASQ,EAAiBR,EAA0C,CACzE,MAAO,CAACD,EAAkBC,CAAM,GAAK,CAAC,CAACA,EAAO,QAChD,CAEO,SAASS,EAAgBT,EAA2C,CACzE,OAAIC,EAA0BD,CAAM,EAC3BA,EAAO,MAGZE,EAA0BF,CAAM,EAC3BA,EAAO,MAGZG,EAA0BH,CAAM,EAC3BA,EAAO,MAGT,CAACA,EAAO,GAAG,CACpB,CAEO,SAASU,EAAcV,EAAuC,CACnE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,OAC/D,CAEO,SAASW,EAAgBX,EAAyC,CACvE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,SAC/D,CAEO,SAASY,EAAgBZ,EAAyC,CACvE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,SAC/D,CAEO,SAASa,EAAeb,EAAwC,CACrE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,QAC/D,CAEO,SAASc,EAAed,EAAwC,CACrE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,QAC/D,CAEO,SAASe,EAAef,EAAwC,CACrE,OAAOO,EAA2BP,CAAM,GAAKA,EAAO,OAAS,QAC/D,CAEO,SAASgB,EAAahB,EAAsC,CACjE,OAAOe,EAAef,CAAM,GAAK,CAAC,CAACA,EAAO,IAC5C,CAEO,SAASiB,EAAcjB,EAA6C,CACzE,OAAOc,EAAed,CAAM,GAAK,CAACA,EAAO,UAC3C,CAEO,SAASkB,EAAYlB,EAAqC,CAC/D,OAAOiB,EAAcjB,CAAM,GAAK,CAAC,CAACA,EAAO,oBAC3C,CAEO,SAASmB,EAAkC,CAAE,KAAAC,CAAK,EAA4B,CACnF,OAAOtB,EAA2BsB,CAAI,CACxC,CAEA,MAAMC,EAAgC,GAE/B,SAASC,EAA6B,CAAE,KAAAF,CAAK,EAA4B,CAC9E,OAAOvB,EAAwCuB,EAAK,UAAUC,CAA6B,CAAC,CAC9F,CAEO,SAASE,EACdC,EACA,CAAE,KAAAJ,CAAK,EACa,CACpB,GAAII,GACF,SAAW,CAACC,EAAMzB,CAAM,IAAK,OAAO,QAAQwB,CAAO,EACjD,GAAIJ,EAAK,SAASK,CAAI,EACpB,OAAOzB,EAMf",
  "names": ["convertFullyQualifiedNameToRelativePath", "simplifyFullyQualifiedName", "isReferenceSchema", "schema", "isAnyOfRuleComposedSchema", "isAllOfRuleComposedSchema", "isOneOfRuleComposedSchema", "isNotRuleComposedSchema", "isComposedSchema", "isNonComposedSchema", "isNonComposedRegularSchema", "isNullableSchema", "decomposeSchema", "isArraySchema", "isBooleanSchema", "isIntegerSchema", "isNumberSchema", "isObjectSchema", "isStringSchema", "isEnumSchema", "isEmptyObject", "isMapSchema", "convertReferenceSchemaToSpecifier", "$ref", "COMPONENTS_SCHEMAS_REF_LENGTH", "convertReferenceSchemaToPath", "resolveReference", "schemas", "name"]
}
