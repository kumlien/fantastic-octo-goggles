import{convertFullyQualifiedNameToRelativePath as S,simplifyFullyQualifiedName as i}from"./utils.js";function a(e){return"$ref"in e}function r(e){return"anyOf"in e}function t(e){return"allOf"in e}function n(e){return"oneOf"in e}function h(e){return"not"in e}function u(e){return r(e)||t(e)||n(e)||h(e)}function l(e){return!u(e)}function o(e){return l(e)&&!a(e)}function O(e){return!a(e)&&!!e.nullable}function x(e){return r(e)?e.anyOf:t(e)?e.allOf:n(e)?e.oneOf:[e.not]}function g(e){return o(e)&&e.type==="array"}function C(e){return o(e)&&e.type==="boolean"}function N(e){return o(e)&&e.type==="integer"}function b(e){return o(e)&&e.type==="number"}function s(e){return o(e)&&e.type==="object"}function y(e){return o(e)&&e.type==="string"}function A(e){return y(e)&&!!e.enum}function R(e){return s(e)&&!e.properties}function j(e){return R(e)&&!!e.additionalProperties}function P({$ref:e}){return i(e)}const f=21;function E({$ref:e}){return S(e.substring(f))}function k(e,{$ref:c}){if(e){for(const[m,p]of Object.entries(e))if(c.includes(m))return p}}export{E as convertReferenceSchemaToPath,P as convertReferenceSchemaToSpecifier,x as decomposeSchema,t as isAllOfRuleComposedSchema,r as isAnyOfRuleComposedSchema,g as isArraySchema,C as isBooleanSchema,u as isComposedSchema,R as isEmptyObject,A as isEnumSchema,N as isIntegerSchema,j as isMapSchema,o as isNonComposedRegularSchema,l as isNonComposedSchema,h as isNotRuleComposedSchema,O as isNullableSchema,b as isNumberSchema,s as isObjectSchema,n as isOneOfRuleComposedSchema,a as isReferenceSchema,y as isStringSchema,k as resolveReference};
//# sourceMappingURL=Schema.js.map
