{
  "version": 3,
  "sources": ["src/ProtectedRoute.tsx"],
  "sourcesContent": ["import { useContext } from 'react';\nimport type { RouteObject } from 'react-router-dom';\nimport { type IndexRouteObject, Navigate, type NonIndexRouteObject, useLocation } from 'react-router-dom';\nimport { type AccessProps, AuthContext } from './useAuth.js';\n\ntype CustomMetadata = Record<string, any>;\n\ntype HandleWithAuth = Readonly<{ handle?: AccessProps & CustomMetadata }>;\n\ntype Override<T, E> = E & Omit<T, keyof E>;\n\ntype IndexRouteObjectWithAuth = Override<IndexRouteObject, HandleWithAuth>;\ntype NonIndexRouteObjectWithAuth = Override<\n  Override<NonIndexRouteObject, HandleWithAuth>,\n  {\n    children?: RouteObjectWithAuth[];\n  }\n>;\nexport type RouteObjectWithAuth = IndexRouteObjectWithAuth | NonIndexRouteObjectWithAuth;\n\ninterface ProtectedRouteProps {\n  redirectPath: string;\n  access: AccessProps;\n  element: JSX.Element;\n}\n\nfunction ProtectedRoute({ redirectPath, access, element }: ProtectedRouteProps): JSX.Element | null {\n  const {\n    state: { initializing, loading, user },\n    hasAccess,\n  } = useContext(AuthContext);\n\n  const location = useLocation();\n\n  if (initializing || loading) {\n    return <div></div>;\n  }\n\n  if (!hasAccess(access)) {\n    return <Navigate to={redirectPath} state={{ from: location }} replace />;\n  }\n\n  return element;\n}\n\nconst collectRoutes = <T,>(routes: T[]): T[] => {\n  const allRoutes: T[] = [];\n  routes.forEach((route) => {\n    allRoutes.push(route);\n    if ((route as RouteObject).children !== undefined) {\n      allRoutes.push(...collectRoutes((route as RouteObject).children as T[]));\n    }\n  });\n  return allRoutes;\n};\n\n/**\n * Adds protection to routes that require authentication.\n * These routes should contain the {@link AccessProps.requiresLogin} and/or\n * {@link AccessProps.rolesAllowed} properties.\n *\n * @param routes - the routes to check if any of them needs to be protected\n * @param redirectPath - the path to redirect to if the route is\n * protected and the user is not authenticated.\n * @returns the routes extended with protection if needed\n */\nexport const protectRoutes = (\n  routes: RouteObjectWithAuth[],\n  redirectPath: string = '/login',\n): RouteObjectWithAuth[] => {\n  const allRoutes: RouteObjectWithAuth[] = collectRoutes(routes);\n\n  allRoutes.forEach((route) => {\n    const { handle } = route;\n    const requiresAuth = handle?.requiresLogin ?? handle?.rolesAllowed?.length;\n\n    if (requiresAuth) {\n      route.element = (\n        <ProtectedRoute\n          redirectPath={redirectPath}\n          access={route.handle as AccessProps}\n          element={route.element as JSX.Element}\n        />\n      );\n    }\n  });\n\n  return routes;\n};\n"],
  "mappings": "AAmCW,cAAAA,MAAA,oBAnCX,OAAS,cAAAC,MAAkB,QAE3B,OAAgC,YAAAC,EAAoC,eAAAC,MAAmB,mBACvF,OAA2B,eAAAC,MAAmB,eAuB9C,SAASC,EAAe,CAAE,aAAAC,EAAc,OAAAC,EAAQ,QAAAC,CAAQ,EAA4C,CAClG,KAAM,CACJ,MAAO,CAAE,aAAAC,EAAc,QAAAC,EAAS,KAAAC,CAAK,EACrC,UAAAC,CACF,EAAIX,EAAWG,CAAW,EAEpBS,EAAWV,EAAY,EAE7B,OAAIM,GAAgBC,EACXV,EAAC,QAAI,EAGTY,EAAUL,CAAM,EAIdC,EAHER,EAACE,EAAA,CAAS,GAAII,EAAc,MAAO,CAAE,KAAMO,CAAS,EAAG,QAAO,GAAC,CAI1E,CAEA,MAAMC,EAAqBC,GAAqB,CAC9C,MAAMC,EAAiB,CAAC,EACxB,OAAAD,EAAO,QAASE,GAAU,CACxBD,EAAU,KAAKC,CAAK,EACfA,EAAsB,WAAa,QACtCD,EAAU,KAAK,GAAGF,EAAeG,EAAsB,QAAe,CAAC,CAE3E,CAAC,EACMD,CACT,EAYaE,EAAgB,CAC3BH,EACAT,EAAuB,YAEkBQ,EAAcC,CAAM,EAEnD,QAASE,GAAU,CAC3B,KAAM,CAAE,OAAAE,CAAO,EAAIF,GACEE,GAAQ,eAAiBA,GAAQ,cAAc,UAGlEF,EAAM,QACJjB,EAACK,EAAA,CACC,aAAcC,EACd,OAAQW,EAAM,OACd,QAASA,EAAM,QACjB,EAGN,CAAC,EAEMF",
  "names": ["jsx", "useContext", "Navigate", "useLocation", "AuthContext", "ProtectedRoute", "redirectPath", "access", "element", "initializing", "loading", "user", "hasAccess", "location", "collectRoutes", "routes", "allRoutes", "route", "protectRoutes", "handle"]
}
