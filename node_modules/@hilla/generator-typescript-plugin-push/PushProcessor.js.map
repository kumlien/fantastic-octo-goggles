{
  "version": 3,
  "sources": ["src/PushProcessor.ts"],
  "sourcesContent": ["import createSourceFile from '@hilla/generator-typescript-utils/createSourceFile.js';\nimport DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport PathManager from '@hilla/generator-typescript-utils/dependencies/PathManager.js';\nimport memoize from '@hilla/generator-typescript-utils/memoize.js';\nimport ts from 'typescript';\n\nconst initParameterTypeName = 'EndpointRequestInit';\n\nexport type EndpointOperations = {\n  methodsToPatch: string[];\n  removeInitImport: boolean;\n};\n\nexport class PushProcessor {\n  readonly #dependencies = new DependencyManager(new PathManager({ extension: '.js' }));\n  readonly #operations: EndpointOperations;\n  readonly #source: ts.SourceFile;\n  readonly #subscriptionId: () => ts.Identifier;\n\n  constructor(source: ts.SourceFile, operations: EndpointOperations) {\n    this.#operations = operations;\n    this.#source = source;\n\n    const { imports, paths } = this.#dependencies;\n\n    this.#dependencies.imports.fromCode(source);\n    this.#subscriptionId = memoize(() =>\n      imports.named.add(paths.createBareModulePath('@hilla/frontend', false), 'Subscription'),\n    );\n  }\n\n  process(): ts.SourceFile {\n    const otherStatements = this.#source.statements\n      .filter((statement) => !ts.isImportDeclaration(statement))\n      .map((statement) => {\n        if (ts.isFunctionDeclaration(statement)) {\n          const functionName = statement.name?.text;\n\n          // Checks if the method is in the list of methods to patch\n          if (functionName && this.#operations.methodsToPatch.includes(functionName)) {\n            return this.#updateFunction(statement);\n          }\n        }\n\n        return statement;\n      });\n\n    let importStatements = this.#dependencies.imports.toCode();\n\n    if (this.#operations.removeInitImport) {\n      const importHillaFrontend = importStatements.find(\n        (statement) =>\n          ts.isImportDeclaration(statement) &&\n          (statement.moduleSpecifier as ts.StringLiteral).text === '@hilla/frontend',\n      );\n\n      if (importHillaFrontend) {\n        const updatedImportStatement = this.#removeInitImport(importHillaFrontend as ts.ImportDeclaration);\n\n        if (updatedImportStatement) {\n          importStatements = importStatements.map((statement) => {\n            if (statement === importHillaFrontend) {\n              return updatedImportStatement;\n            }\n\n            return statement;\n          });\n        }\n      }\n    }\n\n    const updatedStatements: readonly ts.Statement[] = [...importStatements, ...otherStatements];\n\n    return createSourceFile(updatedStatements, this.#source.fileName);\n  }\n\n  #doesInitParameterExist(parameters: ts.NodeArray<ts.ParameterDeclaration>): boolean {\n    const last = parameters[parameters.length - 1];\n    const lastType = last.type as ts.TypeReferenceNode;\n    const lastTypeName = lastType.typeName as ts.Identifier;\n\n    return lastTypeName.text === initParameterTypeName;\n  }\n\n  #removeInitImport = (importStatement: ts.ImportDeclaration): ts.Statement | undefined => {\n    const namedImports = importStatement.importClause?.namedBindings;\n    if (namedImports && ts.isNamedImports(namedImports)) {\n      const updatedElements = namedImports.elements.filter((element) => element.name.text !== 'EndpointRequestInit');\n\n      const updatedImportClause = ts.factory.updateImportClause(\n        importStatement.importClause,\n        false, // FIXME: could be true, but it is false for regular endpoint calls, so sticking to that for now\n        undefined,\n        ts.factory.createNamedImports(updatedElements),\n      );\n\n      return ts.factory.updateImportDeclaration(\n        importStatement,\n        undefined,\n        updatedImportClause,\n        importStatement.moduleSpecifier,\n        undefined,\n      );\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Replace returned `Promise<Array<T>>` by the `Subscription<T>` type\n   * @param declaration -\n   */\n  #replacePromiseType(declaration: ts.FunctionDeclaration) {\n    const promiseType = (declaration.type as ts.TypeReferenceNode).typeArguments![0];\n    const promiseArray = (ts.isUnionTypeNode(promiseType) ? promiseType.types[0] : promiseType) as ts.TypeReferenceNode;\n\n    return ts.factory.createTypeReferenceNode(this.#subscriptionId(), promiseArray.typeArguments);\n  }\n\n  #updateFunction(declaration: ts.FunctionDeclaration): ts.FunctionDeclaration {\n    const { parameters } = declaration;\n    const doesInitParameterExist = this.#doesInitParameterExist(parameters);\n\n    return ts.factory.createFunctionDeclaration(\n      undefined, // no async\n      declaration.asteriskToken,\n      declaration.name,\n      declaration.typeParameters,\n      // Remove the `init` parameter\n      doesInitParameterExist ? parameters.slice(0, -1) : parameters,\n      this.#replacePromiseType(declaration),\n      this.#updateFunctionBody(declaration, doesInitParameterExist),\n    );\n  }\n\n  #updateFunctionBody(declaration: ts.FunctionDeclaration, doesInitParameterExist: boolean): ts.Block {\n    const returnStatement = declaration.body!.statements[0] as ts.ReturnStatement;\n    const { arguments: args, expression, typeArguments } = returnStatement.expression! as ts.CallExpression;\n    const call = expression as ts.PropertyAccessExpression;\n\n    return ts.factory.createBlock([\n      ts.factory.createReturnStatement(\n        ts.factory.createCallExpression(\n          ts.factory.createPropertyAccessExpression(\n            call.expression,\n            // `subscribe` instead of `call`\n            ts.factory.createIdentifier('subscribe'),\n          ),\n          typeArguments,\n          // remove the `init` parameter\n          doesInitParameterExist ? args.slice(0, -1) : args,\n        ),\n      ),\n    ]);\n  }\n}\n"],
  "mappings": "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",
  "names": ["createSourceFile", "DependencyManager", "PathManager", "memoize", "ts", "initParameterTypeName", "PushProcessor", "#dependencies", "#operations", "#source", "#subscriptionId", "source", "operations", "imports", "paths", "otherStatements", "statement", "functionName", "#updateFunction", "importStatements", "importHillaFrontend", "updatedImportStatement", "#removeInitImport", "updatedStatements", "#doesInitParameterExist", "parameters", "importStatement", "namedImports", "updatedElements", "element", "updatedImportClause", "#replacePromiseType", "declaration", "promiseType", "promiseArray", "doesInitParameterExist", "#updateFunctionBody", "returnStatement", "args", "expression", "typeArguments", "call"]
}
