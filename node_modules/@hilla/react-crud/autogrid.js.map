{
  "version": 3,
  "sources": ["src/autogrid.tsx"],
  "sourcesContent": ["import type { AbstractModel, DetachedModelConstructor } from '@hilla/form';\nimport {\n  Grid,\n  type GridDataProvider,\n  type GridDataProviderCallback,\n  type GridDataProviderParams,\n  type GridDefaultItem,\n  type GridElement,\n  type GridProps,\n} from '@hilla/react-components/Grid.js';\nimport { GridColumn } from '@hilla/react-components/GridColumn.js';\nimport { GridColumnGroup } from '@hilla/react-components/GridColumnGroup.js';\nimport { useEffect, useRef, useState, type JSX, type MutableRefObject } from 'react';\nimport { ColumnContext, type SortState } from './autogrid-column-context.js';\nimport { type ColumnOptions, getColumnOptions } from './autogrid-columns.js';\nimport { AutoGridRowNumberRenderer } from './autogrid-renderers.js';\nimport type { ListService } from './crud';\nimport { HeaderSorter } from './header-sorter';\nimport { getIdProperty, getProperties, includeProperty, type PropertyInfo } from './property-info.js';\nimport type AndFilter from './types/dev/hilla/crud/filter/AndFilter.js';\nimport type Filter from './types/dev/hilla/crud/filter/Filter.js';\nimport type PropertyStringFilter from './types/dev/hilla/crud/filter/PropertyStringFilter.js';\nimport type Sort from './types/dev/hilla/mappedtypes/Sort.js';\nimport Direction from './types/org/springframework/data/domain/Sort/Direction.js';\n\ninterface AutoGridOwnProps<TItem> {\n  /**\n   * The service to use for fetching the data. This must be a TypeScript service\n   * that has been generated by Hilla from a backend Java service that\n   * implements the `dev.hilla.crud.ListService` interface.\n   */\n  service: ListService<TItem>;\n  /**\n   * The entity model to use for the grid, which determines which columns to\n   * show and how to render them. This must be a Typescript model class that has\n   * been generated by Hilla from a backend Java class. The model must match\n   * with the type of the items returned by the service. For example, a\n   * `PersonModel` can be used with a service that returns `Person` instances.\n   *\n   * By default, the grid shows columns for all properties of the model which\n   * have a type that is supported. Use the `visibleColumns` option to customize\n   * which columns to show and in which order.\n   */\n  model: DetachedModelConstructor<AbstractModel<TItem>>;\n  /**\n   * Allows to provide a filter that is applied when fetching data from the\n   * service. This can be used for implementing an external filter UI outside\n   * the grid. A custom filter is not compatible with header filters.\n   *\n   * **NOTE:** This is considered an experimental feature and the API may change\n   * in the future.\n   */\n  experimentalFilter?: Filter;\n  /**\n   * Allows to customize which columns to show and in which order. This must be\n   * an array of property names that are defined in the model. Nested properties\n   * can be specified using dot notation, e.g. `address.street`.\n   */\n  visibleColumns?: string[];\n  /**\n   * Disables header filters, which are otherwise enabled by default.\n   */\n  noHeaderFilters?: boolean;\n  /**\n   * Can be used to force the grid to reload data. Passing a different value\n   * between renders will trigger a reload.\n   */\n  refreshTrigger?: number;\n  /**\n   * Allows to add custom columns to the grid. This must be an array of\n   * `GridColumn` component instances. Custom columns are added after the\n   * auto-generated columns.\n   */\n  customColumns?: JSX.Element[];\n  /**\n   * Allows to customize the props for individual columns. This is an object\n   * where the keys must be property names that are defined in the model, and\n   * the values are props that are accepted by the `GridColumn` component.\n   * Nested properties can be specified using dot notation, e.g.\n   * `address.street`.\n   */\n  columnOptions?: Record<string, ColumnOptions>;\n  /**\n   * When enabled, inserts a column with row numbers at the beginning of the\n   * grid.\n   */\n  rowNumbers?: boolean;\n}\n\nexport type AutoGridProps<TItem> = GridProps<TItem> & Readonly<AutoGridOwnProps<TItem>>;\n\ntype GridElementWithInternalAPI<TItem = GridDefaultItem> = GridElement<TItem> &\n  Readonly<{\n    _cache: {\n      size?: number;\n    };\n  }>;\n\nfunction createDataProvider<TItem>(\n  grid: GridElement<TItem>,\n  service: ListService<TItem>,\n  filter: MutableRefObject<Filter | undefined>,\n): GridDataProvider<TItem> {\n  let first = true;\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return async (params: GridDataProviderParams<TItem>, callback: GridDataProviderCallback<TItem>) => {\n    const sort: Sort = {\n      orders: params.sortOrders\n        .filter((order) => order.direction != null)\n        .map((order) => ({\n          property: order.path,\n          direction: order.direction === 'asc' ? Direction.ASC : Direction.DESC,\n          ignoreCase: false,\n        })),\n    };\n\n    const pageNumber = params.page;\n    const { pageSize } = params;\n    const req = {\n      pageNumber,\n      pageSize,\n      sort,\n    };\n\n    const items = await service.list(req, filter.current);\n    let size;\n    if (items.length === pageSize) {\n      size = (pageNumber + 1) * pageSize + 1;\n\n      const cacheSize = (grid as GridElementWithInternalAPI<TItem>)._cache.size;\n      if (cacheSize !== undefined && size < cacheSize) {\n        // Only allow size to grow here to avoid shrinking the size when scrolled down and sorting\n        size = undefined;\n      }\n    } else {\n      size = pageNumber * pageSize + items.length;\n    }\n    callback(items, size);\n    if (first) {\n      // Workaround for https://github.com/vaadin/react-components/issues/129\n      first = false;\n      setTimeout(() => grid.recalculateColumnWidths(), 0);\n    }\n  };\n}\n\nfunction useColumns(\n  properties: PropertyInfo[],\n  setPropertyFilter: (propertyFilter: PropertyStringFilter) => void,\n  options: {\n    visibleColumns?: string[];\n    noHeaderFilters?: boolean;\n    customColumns?: JSX.Element[];\n    columnOptions?: Record<string, ColumnOptions>;\n    rowNumbers?: boolean;\n  },\n) {\n  const effectiveColumns = options.visibleColumns ?? properties.filter(includeProperty).map((p) => p.name);\n  const effectiveProperties = effectiveColumns\n    .map((name) => properties.find((prop) => prop.name === name))\n    .filter(Boolean) as PropertyInfo[];\n\n  const [sortState, setSortState] = useState<SortState>(\n    effectiveProperties.length > 0 ? { [effectiveProperties[0].name]: { direction: 'asc' } } : {},\n  );\n\n  let columns = effectiveProperties.map((propertyInfo) => {\n    let column;\n\n    const customColumnOptions = options.columnOptions ? options.columnOptions[propertyInfo.name] : undefined;\n\n    // Header renderer is effectively the header filter, which should only be\n    // applied when header filters are enabled\n    const { headerRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);\n\n    if (!options.noHeaderFilters) {\n      column = (\n        <GridColumnGroup headerRenderer={HeaderSorter}>\n          <GridColumn path={propertyInfo.name} headerRenderer={headerRenderer} {...columnProps}></GridColumn>\n        </GridColumnGroup>\n      );\n    } else {\n      column = <GridColumn path={propertyInfo.name} headerRenderer={HeaderSorter} {...columnProps}></GridColumn>;\n    }\n    return (\n      <ColumnContext.Provider\n        key={propertyInfo.name}\n        value={{ propertyInfo, setPropertyFilter, sortState, setSortState, customColumnOptions }}\n      >\n        {column}\n      </ColumnContext.Provider>\n    );\n  });\n\n  if (options.customColumns) {\n    columns = [...columns, ...options.customColumns];\n  }\n\n  if (options.rowNumbers) {\n    columns = [<GridColumn key=\"rownumbers\" width=\"4em\" renderer={AutoGridRowNumberRenderer}></GridColumn>, ...columns];\n  }\n\n  return columns;\n}\n\n/**\n * Auto Grid is a component for displaying tabular data based on a Java backend\n * service. It automatically generates columns based on the properties of a\n * Java class and provides features such as lazy-loading, sorting and filtering.\n *\n * Example usage:\n * ```tsx\n * import { AutoGrid } from '@hilla/react-grid';\n * import PersonService from 'Frontend/generated/endpoints';\n * import PersonModel from 'Frontend/generated/com/example/application/Person';\n *\n * <AutoGrid service={PersonService} model={PersonModel} />\n * ```\n */\nexport function AutoGrid<TItem>({\n  service,\n  model,\n  experimentalFilter,\n  visibleColumns,\n  noHeaderFilters,\n  refreshTrigger = 0,\n  customColumns,\n  columnOptions,\n  rowNumbers,\n  ...gridProps\n}: AutoGridProps<TItem>): JSX.Element {\n  const [internalFilter, setInternalFilter] = useState<AndFilter>({ ...{ t: 'and' }, children: [] });\n\n  const setHeaderPropertyFilter = (propertyFilter: PropertyStringFilter) => {\n    const filterIndex = internalFilter.children.findIndex(\n      (f) => (f as PropertyStringFilter).propertyId === propertyFilter.propertyId,\n    );\n    let changed = false;\n    if (propertyFilter.filterValue === '') {\n      // Delete empty filter\n      if (filterIndex >= 0) {\n        internalFilter.children.splice(filterIndex, 1);\n        changed = true;\n      }\n    } else if (filterIndex >= 0) {\n      internalFilter.children[filterIndex] = propertyFilter;\n      changed = true;\n    } else {\n      internalFilter.children.push(propertyFilter);\n      changed = true;\n    }\n    if (changed) {\n      setInternalFilter({ ...internalFilter });\n    }\n  };\n\n  const properties = getProperties(model);\n  const children = useColumns(properties, setHeaderPropertyFilter, {\n    visibleColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n  });\n\n  useEffect(() => {\n    // Remove all filtering if header filters are removed\n    if (noHeaderFilters) {\n      setInternalFilter({ ...{ t: 'and' }, children: [] });\n    }\n  }, [noHeaderFilters]);\n\n  const ref = useRef<GridElement<TItem>>(null);\n  const dataProviderFilter = useRef<Filter | undefined>(undefined);\n\n  useEffect(() => {\n    // Sets the data provider, should be done only once\n    const grid = ref.current!;\n    setTimeout(() => {\n      // Wait for the sorting headers to be rendered so that the sorting state is correct for the first data provider call\n      grid.dataProvider = createDataProvider(grid, service, dataProviderFilter);\n    }, 1);\n  }, [model, service]);\n\n  useEffect(() => {\n    // Update the filtering, whenever the filter changes\n    const grid = ref.current;\n    if (grid) {\n      dataProviderFilter.current = experimentalFilter ?? internalFilter;\n      grid.clearCache();\n    }\n  }, [experimentalFilter, internalFilter, refreshTrigger]);\n\n  return <Grid itemIdPath={getIdProperty(properties)?.name} {...gridProps} ref={ref} children={children}></Grid>;\n}\n"],
  "mappings": "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",
  "names": ["jsx", "Grid", "GridColumn", "GridColumnGroup", "useEffect", "useRef", "useState", "ColumnContext", "getColumnOptions", "AutoGridRowNumberRenderer", "HeaderSorter", "getIdProperty", "getProperties", "includeProperty", "Direction", "createDataProvider", "grid", "service", "filter", "first", "params", "callback", "sort", "order", "pageNumber", "pageSize", "req", "items", "size", "cacheSize", "useColumns", "properties", "setPropertyFilter", "options", "effectiveProperties", "p", "name", "prop", "sortState", "setSortState", "columns", "propertyInfo", "column", "customColumnOptions", "headerRenderer", "columnProps", "AutoGrid", "model", "experimentalFilter", "visibleColumns", "noHeaderFilters", "refreshTrigger", "customColumns", "columnOptions", "rowNumbers", "gridProps", "internalFilter", "setInternalFilter", "setHeaderPropertyFilter", "propertyFilter", "filterIndex", "f", "changed", "children", "ref", "dataProviderFilter"]
}
